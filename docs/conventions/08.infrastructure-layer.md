# 8. 인프라스트럭처 레이어 규약

## 1. 개요

본 문서는 Voyage-Shop 애플리케이션의 인프라스트럭처(Infrastructure) 레이어 개발 시 일관성을 유지하고, 코드 가독성 및 유지보수성을 향상시키기 위한 규약을 정의합니다. 모든 개발자는 본 규약을 숙지하고 준수하는 것을 원칙으로 합니다.

아키텍처 개요는 다음 문서들을 참조하세요:
- [1. 프로젝트 컨벤션 개요](./01.common-conventions.md)
- [7. 도메인 레이어 컨벤션](./07.domain-layer.md)

인프라스트럭처 레이어의 주요 역할은 도메인 레이어에서 정의한 인터페이스의 구현체를 제공하고, 외부 시스템과의 통합을 담당하는 것입니다. 이 레이어는 데이터베이스, 외부 API, 메시징 시스템 등과 같은 기술적 세부사항을 캡슐화하며, 도메인 레이어가 이러한 세부사항에 의존하지 않도록 보장합니다.

## 2. 디렉토리 구조

```
/infrastructure
  /repository/               # 레포지토리 구현체
    /jpa/                    # JPA 기반 구현
      /도메인명/
        DomainJpaRepository.kt  # Spring Data JPA 인터페이스
        DomainJpaEntity.kt      # JPA 엔티티
        DomainRepositoryImpl.kt # 도메인 레포지토리 구현체
    /inmemory/               # 인메모리(테스트용) 구현
      /도메인명/
        DomainInMemoryRepository.kt
  /client/                   # 외부 API 클라이언트
    /외부서비스명/
      ExternalServiceClient.kt
      ExternalServiceProperties.kt
  /messaging/                # 메시징 관련 구현
    /kafka/
      KafkaProducerConfig.kt
      KafkaConsumerConfig.kt
  /cache/                    # 캐시 관련 구현
    RedisCacheConfig.kt
  /config/                   # 인프라 관련 설정
    DatabaseConfig.kt
    SecurityConfig.kt
```

## 3. 레포지토리 구현 (Repository Implementation)

### 3.1 기본 구조

```kotlin
@Repository
class UserRepositoryImpl(
    private val userJpaRepository: UserJpaRepository,
    private val userMapper: UserMapper
) : UserRepository {
    // 메서드 구현
}
```

### 3.2 레포지토리 설계 원칙

1. **인터페이스 구현**: 도메인 레이어에 정의된 레포지토리 인터페이스를 구현
2. **기술 독립성**: 도메인 모델을 인프라스트럭처 기술(JPA 등)로부터 독립적으로 유지
3. **매핑 책임**: 영속성 모델(JPA 엔티티)과 도메인 모델 간 매핑 처리
4. **예외 변환**: 인프라스트럭처 예외를 도메인 예외로 변환
5. **트랜잭션 관리 없음**: 트랜잭션 관리는 애플리케이션 레이어에서 담당

### 3.3 매핑 전략

인프라스트럭처 레이어에서는 도메인 모델과 영속성 모델(JPA 엔티티 등) 간의 매핑을 담당합니다. 이때 다음 전략을 고려합니다:

1. **매퍼 클래스 사용**: 복잡한 매핑 로직이 필요한 경우 별도의 매퍼 클래스 사용
   ```kotlin
   @Component
   class UserMapper {
       fun toEntity(domain: User): UserJpaEntity {
           // 도메인 -> 엔티티 매핑 로직
       }
       
       fun toDomain(entity: UserJpaEntity): User {
           // 엔티티 -> 도메인 매핑 로직
       }
   }
   ```

2. **확장 함수 활용**: 간단한 매핑은 확장 함수로 구현
   ```kotlin
   private fun UserJpaEntity.toDomain(): User {
       return User(
           userId = userId,
           // 다른 필드 매핑
       )
   }
   ```

3. **팩토리 메서드 활용**: 도메인 객체 생성 시 팩토리 메서드 활용
   ```kotlin
   private fun createUserFrom(entity: UserJpaEntity): User {
       return User.of(
           userId = entity.userId,
           // 다른 파라미터
       )
   }
   ```

## 4. JPA 엔티티 (JPA Entity)

### 4.1 기본 구조

```kotlin
@Entity
@Table(name = "users")
class UserJpaEntity(
    @Id
    @Column(name = "user_id")
    val userId: String,
    
    @Column(name = "created_at", nullable = false)
    val createdAt: LocalDateTime,
    
    @Column(name = "updated_at", nullable = false)
    var updatedAt: LocalDateTime
) {
    // 필요시 메서드 추가
}
```

### 4.2 JPA 엔티티 설계 원칙

1. **명확한 네이밍**: 클래스명에 JpaEntity 접미사 사용
2. **테이블명 명시**: @Table 어노테이션으로 테이블명 명시 (복수형 권장)
3. **컬럼명 명시**: @Column 어노테이션으로 컬럼명 명시 (snake_case 권장)
4. **감사 필드 포함**: 생성일시와 수정일시 필드 포함
5. **값 객체 매핑**: 값 객체는 @Embeddable/@Embedded 활용
6. **관계 설정**: 연관관계는 명시적으로 설정 (@OneToMany, @ManyToOne 등)
7. **인덱스 정의**: 필요한 인덱스는 @Index로 명시

### 4.3 JPA 엔티티 예시

```kotlin
@Entity
@Table(
    name = "orders",
    indexes = [
        Index(name = "idx_orders_user_id", columnList = "user_id"),
        Index(name = "idx_orders_created_at", columnList = "created_at")
    ]
)
class OrderJpaEntity(
    @Id
    @Column(name = "order_id")
    val orderId: String,
    
    @Column(name = "user_id", nullable = false)
    val userId: String,
    
    @Column(name = "payment_id")
    val paymentId: String?,
    
    @Column(name = "total_amount", nullable = false)
    val totalAmount: Long,
    
    @Column(name = "status", nullable = false)
    var status: String,
    
    @OneToMany(mappedBy = "order", cascade = [CascadeType.ALL], orphanRemoval = true)
    val orderItems: MutableList<OrderItemJpaEntity> = mutableListOf(),
    
    @Column(name = "created_at", nullable = false)
    val createdAt: LocalDateTime,
    
    @Column(name = "updated_at", nullable = false)
    var updatedAt: LocalDateTime
) {
    // 필요한 비즈니스 로직이나 조회 메서드 추가
}
```

## 5. Spring Data JPA 저장소 (Spring Data JPA Repository)

### 5.1 기본 구조

```kotlin
@Repository
interface UserJpaRepository : JpaRepository<UserJpaEntity, String> {
    // 쿼리 메서드 추가
}
```

### 5.2 JPA 저장소 설계 원칙

1. **네이밍 규칙**: 클래스명에 JpaRepository 접미사 사용
2. **쿼리 메서드**: 가능한 경우 쿼리 메서드 네이밍 규칙 활용
3. **쿼리 어노테이션**: 복잡한 쿼리는 @Query 어노테이션 활용
4. **페이징 지원**: 목록 조회 시 페이징 기능 지원
5. **비동기 지원**: 필요한 경우 비동기 메서드 활용 (CompletableFuture, Reactive 등)

## 6. 외부 API 클라이언트 (External API Client)

### 6.1 기본 구조

```kotlin
@Component
class PaymentApiClient(
    private val webClient: WebClient,
    private val properties: PaymentApiProperties
) {
    // API 호출 메서드
}

@ConfigurationProperties(prefix = "external.payment-api")
data class PaymentApiProperties(
    val baseUrl: String,
    val apiKey: String,
    val timeout: Duration
)
```

### 6.2 API 클라이언트 설계 원칙

1. **클라이언트 추상화**: 외부 서비스의 세부 구현 및 프로토콜 추상화
2. **설정 분리**: API 관련 설정은 Properties 클래스로 분리
3. **타임아웃 설정**: 모든 API 호출에 타임아웃 설정
4. **재시도 메커니즘**: 필요한 경우 재시도 로직 구현
5. **응답 매핑**: API 응답을 도메인 모델로 매핑
6. **예외 처리**: 외부 API 예외를 애플리케이션 예외로 변환
7. **로깅**: API 호출 로그 남기기 (요청/응답 내용, 소요 시간 등)

## 7. 캐시 관리 (Cache Management)

### 7.1 기본 구조

```kotlin
@EnableCaching
@Configuration
class CacheConfig {
    @Bean
    fun cacheManager(): CacheManager {
        // 캐시 매니저 설정
    }
}

@Component
class ProductCacheService(
    private val cacheManager: CacheManager
) {
    // 캐시 관련 메서드
}
```

### 7.2 캐시 설계 원칙

1. **캐시 추상화**: Spring의 캐시 추상화(CacheManager) 활용
2. **명시적 TTL**: 모든 캐시에 명시적인 TTL(Time To Live) 설정
3. **세분화된 캐시**: 도메인별/기능별로 세분화된 캐시 이름 사용
4. **캐시 키 설계**: 명확하고 구분 가능한 캐시 키 설계
5. **조건부 캐싱**: 필요한 경우 조건부 캐싱 활용(@CachePut, @CacheEvict 등)

## 8. 메시징 및 이벤트 처리 (Messaging & Events)

### 8.1 기본 구조

```kotlin
@Component
class OrderEventPublisher(
    private val kafkaTemplate: KafkaTemplate<String, OrderEvent>
) {
    // 이벤트 발행 메서드
}

@Component
class OrderEventConsumer {
    @KafkaListener(topics = ["orders"])
    fun handleOrderEvent(orderEvent: OrderEvent) {
        // 이벤트 처리 로직
    }
}
```

### 8.2 메시징 설계 원칙

1. **이벤트 규약**: 명확한 이벤트 구조 및 네이밍 규약 정의
2. **발행-구독 분리**: 이벤트 발행과 구독 로직 분리
3. **멱등성 보장**: 이벤트 중복 처리에 대비한 멱등성 보장
4. **장애 허용**: 메시징 시스템 장애 대응 방안 마련
5. **트랜잭션 통합**: 필요한 경우 DB 트랜잭션과 메시지 발행 통합

## 9. 보안 관련 구성 (Security Configuration)

### 9.1 기본 구조

```kotlin
@Configuration
@EnableWebSecurity
class SecurityConfig {
    @Bean
    fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {
        // 보안 설정
    }
}
```

### 9.2 보안 설계 원칙

1. **최소 권한 원칙**: 필요한 최소한의 권한만 부여
2. **명시적 설정**: 모든 보안 관련 설정을 명시적으로 구성
3. **환경별 구성**: 개발, 테스트, 운영 환경별 보안 구성 분리
4. **민감 정보 관리**: 암호, API 키 등 민감 정보 관리 방안 마련
5. **토큰 기반 인증**: JWT 등 토큰 기반 인증 메커니즘 활용

## 10. 테스트 (Testing)

### 10.1 테스트 대상

인프라스트럭처 레이어 테스트는 다음 두 수준으로 작성합니다:

1. **통합 테스트**: 실제 인프라스트럭처와 통합한 테스트
   - 데이터베이스 연동 테스트
   - 외부 API 연동 테스트
   - 테스트 컨테이너(TestContainers) 활용

2. **단위 테스트**: Mocking을 활용한 단위 테스트
   - 외부 의존성을 Mocking하여 격리된 테스트

### 10.2 테스트 네이밍 규칙

- 통합 테스트: `{클래스명}IntegrationTest`
- 단위 테스트: `{클래스명}Test`

### 10.3 통합 테스트 예시

```kotlin
@SpringBootTest
@Import(TestcontainersConfiguration::class)
class UserRepositoryImplIntegrationTest {
    @Autowired
    private lateinit var userRepository: UserRepository
    
    @Autowired
    private lateinit var userJpaRepository: UserJpaRepository
    
    @BeforeEach
    fun setUp() {
        userJpaRepository.deleteAll()
    }
    
    @Test
    @DisplayName("사용자 생성 후 조회 테스트")
    fun createAndFindUser() {
        // given
        val user = User(/* 필요한 파라미터 */)
        
        // when
        val savedUser = userRepository.save(user)
        val foundUser = userRepository.findById(savedUser.userId)
        
        // then
        assertNotNull(foundUser)
        assertEquals(user.userId, foundUser?.userId)
    }
}
```

## 11. 예외 처리 (Exception Handling)

### 11.1 예외 처리 원칙

1. **예외 변환**: 인프라스트럭처 관련 예외는 도메인 예외로 변환
2. **예외 래핑**: 기술적 예외는 애플리케이션 예외로 래핑
3. **예외 문서화**: 발생 가능한 예외를 메서드 주석에 명시적으로 문서화
4. **로깅**: 인프라스트럭처 예외 발생 시 충분한 컨텍스트와 함께 로깅

### 11.2 예외 처리 예시

```kotlin
override fun findById(userId: String): User? {
    try {
        val userEntity = userJpaRepository.findById(userId).orElse(null) ?: return null
        return userMapper.toDomain(userEntity)
    } catch (e: DataAccessException) {
        log.error("사용자 조회 중 데이터베이스 오류 발생: userId={}", userId, e)
        throw UserException.RepositoryError("사용자 조회 중 오류가 발생했습니다: ${e.message}")
    }
}
```

## 12. 성능 고려사항 (Performance Considerations)

1. **N+1 쿼리 방지**: JPA 사용 시 N+1 쿼리 문제 주의
   - 필요한 경우 fetch join 활용
   - 배치 로딩 전략 고려

2. **인덱스 활용**: 적절한 인덱스 설계 및 활용
   - 쿼리 패턴에 따른 인덱스 설계
   - 복합 인덱스 활용

3. **페이징 처리**: 대용량 데이터 조회 시 페이징 처리
   - Offset 기반 페이징
   - Cursor 기반 페이징 고려

4. **벌크 연산**: 대량 데이터 처리 시 벌크 연산 활용
   - 배치 삽입 (batch insert)
   - 벌크 업데이트 (bulk update) 