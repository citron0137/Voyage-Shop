# 8. 인프라스트럭처 레이어 규약

## 1. 개요

본 문서는 Voyage-Shop 애플리케이션의 인프라스트럭처(Infrastructure) 레이어 개발 시 일관성을 유지하고, 코드 가독성 및 유지보수성을 향상시키기 위한 규약을 정의합니다. 모든 개발자는 본 규약을 숙지하고 준수하는 것을 원칙으로 합니다.

아키텍처 개요는 다음 문서들을 참조하세요:
- [1. 프로젝트 컨벤션 개요](./01.common-conventions.md)
- [7. 도메인 레이어 컨벤션](./07.domain-layer.md)

인프라스트럭처 레이어의 주요 역할은 도메인 레이어에서 정의한 인터페이스의 구현체를 제공하고, 외부 시스템과의 통합을 담당하는 것입니다. 이 레이어는 데이터베이스, 외부 API 같은 기술적 세부사항을 캡슐화하며, 도메인 레이어가 이러한 세부사항에 의존하지 않도록 보장합니다.

## 2. 디렉토리 구조

```
/infrastructure
  /도메인명/
    DomainJpaRepository.kt  # Spring Data JPA 인터페이스
    DomainJpaEntity.kt      # JPA 엔티티
    DomainRepositoryImpl.kt # 도메인 레포지토리 구현체
  /config/                   # 인프라 관련 설정
    DatabaseConfig.kt
```

## 3. 레포지토리 구현 (Repository Implementation)

### 3.1 기본 구조

```kotlin
@Repository
class UserRepositoryImpl(
    private val userJpaRepository: UserJpaRepository
) : UserRepository {
    // 메서드 구현
}
```

### 3.2 레포지토리 설계 원칙

1. **인터페이스 구현**: 도메인 레이어에 정의된 레포지토리 인터페이스를 구현
2. **기술 독립성**: 도메인 모델을 인프라스트럭처 기술(JPA 등)로부터 독립적으로 유지
3. **매핑 책임**: 영속성 모델(JPA 엔티티)과 도메인 모델 간 매핑 처리
4. **예외 변환**: 인프라스트럭처 예외를 도메인 예외로 변환
5. **트랜잭션 관리 없음**: 트랜잭션 관리는 애플리케이션 레이어에서 담당

### 3.3 매핑 전략

인프라스트럭처 레이어에서는 도메인 모델과 영속성 모델(JPA 엔티티 등) 간의 매핑을 담당합니다. 이때 다음 전략을 고려합니다:

1. **매퍼 클래스 분리**: 복잡한 매핑 로직은 별도의 매퍼 클래스로 분리
2. **직접 변환 메소드**: 간단한 매핑은 엔티티에 직접 변환 메소드 구현
3. **변환 메소드 명명 규칙**: 영속성 엔티티에는 다음과 같은 변환 메소드 명명 규칙을 사용
   - `from(domain)`: 도메인 모델을 받아 JPA 엔티티로 변환
   - `to()`: JPA 엔티티를 도메인 모델로 변환
4. **값 객체 매핑**: 값 객체는 Embeddable로 관리하고 적절한 변환 로직 제공

매핑 전략에 대한 자세한 예시는 [4. JPA 엔티티](#4-jpa-엔티티-jpa-entity) 섹션을 참고하세요.

## 4. JPA 엔티티 (JPA Entity)

### 4.1 기본 구조

```kotlin
@Entity
@Table(name = "users")
class UserJpaEntity(
    @Id
    @Column(name = "user_id")
    val userId: String,
    
    @Column(name = "created_at")
    val createdAt: LocalDateTime,
    
    @Column(name = "updated_at")
    var updatedAt: LocalDateTime
) {
    companion object {
        fun from(domain: User): UserJpaEntity {
            return UserJpaEntity(
                userId = domain.userId,
                createdAt = domain.createdAt,
                updatedAt = domain.updatedAt
            )
        }
    }

    fun to(): User {
        return User(
            userId = this.userId,
            createdAt = this.createdAt,
            updatedAt = this.updatedAt
        )
    }
}
```

### 4.2 JPA 엔티티 설계 원칙

1. **명확한 네이밍**: 클래스명에 JpaEntity 접미사 사용
2. **테이블명 명시**: @Table 어노테이션으로 테이블명 명시 (복수형 권장)
3. **컬럼명 명시**: @Column 어노테이션으로 컬럼명 명시 (snake_case 권장)
4. **감사 필드 포함**: 생성일시와 수정일시 필드 포함
5. **값 객체 매핑**: 값 객체는 @Embeddable/@Embedded 활용
6. **관계 설정**: 강결합된 엔티티에만 연관관계 설정, 그 외에는 ID 참조 방식 선호 (세부사항은 4.3 JPA 연관관계 설계 지침 참조)
7. **인덱스 정의**: 필요한 인덱스는 @Index로 명시
8. **Nullability 설정**: 기본적으로 모든 필드는 null을 허용하지 않음(`nullable = false`), nullable인 경우에만 명시적으로 지정
   ```kotlin
   // 기본적으로 null을 허용하지 않는 필드
   @Column(name = "username")  // nullable = false가 기본값이므로 생략 가능
   val username: String
   
   // null을 허용하는 필드
   @Column(name = "middle_name", nullable = true)
   val middleName: String?
   ```

### 4.3 JPA 연관관계 설계 지침

1. **연관관계 최소화**: 강결합된 엔티티가 아닌 경우 @OneToMany, @ManyToOne 등의 연관관계 사용을 지양하고 ID 참조 방식 선호
   - 이유: 연관관계는 객체 그래프 탐색을 편리하게 하지만, 성능 이슈(N+1 문제 등)와 복잡성을 증가시킬 수 있음
   - 예외: 주문-주문상품과 같이 라이프사이클이 완전히 동일하고 항상 함께 조회/수정되는 강결합 관계

4. **강결합 판단 기준**:
   - 항상 함께 생성/수정/삭제되는가?
   - 독립적으로 존재할 수 있는가?
   - 항상 함께 조회되는가?
   - 트랜잭션 경계가 동일한가?

## 5. Spring Data JPA 저장소 (Spring Data JPA Repository)

### 5.1 기본 구조

```kotlin
@Repository
interface UserJpaRepository : JpaRepository<UserJpaEntity, String> {
    // 쿼리 메서드 추가
}
```

### 5.2 JPA 저장소 설계 원칙

1. **네이밍 규칙**: 클래스명에 JpaRepository 접미사 사용
2. **쿼리 메서드**: 가능한 경우 쿼리 메서드 네이밍 규칙 활용
3. **쿼리 어노테이션**: 복잡한 쿼리는 @Query 어노테이션 활용
4. **페이징 지원**: 목록 조회 시 필요한 경우 페이징 기능 지원

