# 8. 인프라스트럭처 레이어 규약

## 1. 개요

본 문서는 Voyage-Shop 애플리케이션의 인프라스트럭처(Infrastructure) 레이어 개발 시 일관성을 유지하고, 코드 가독성 및 유지보수성을 향상시키기 위한 규약을 정의합니다. 모든 개발자는 본 규약을 숙지하고 준수하는 것을 원칙으로 합니다.

아키텍처 개요는 다음 문서들을 참조하세요:
- [1. 프로젝트 컨벤션 개요](./01.common-conventions.md)
- [7. 도메인 레이어 컨벤션](./07.domain-layer.md)

인프라스트럭처 레이어의 주요 역할은 도메인 레이어에서 정의한 인터페이스의 구현체를 제공하고, 외부 시스템과의 통합을 담당하는 것입니다. 이 레이어는 데이터베이스, 외부 API 같은 기술적 세부사항을 캡슐화하며, 도메인 레이어가 이러한 세부사항에 의존하지 않도록 보장합니다.

## 2. 디렉토리 구조

```
/infrastructure
  /도메인명/                          # 도메인별 패키지
    DomainJpaRepository.kt           # Spring Data JPA 인터페이스
    DomainJpaEntity.kt               # JPA 엔티티
    DomainRepositoryImpl.kt          # 도메인 레포지토리 구현체
    DomainApiClient.kt               # 도메인 관련 외부 API 클라이언트 (필요시)
    DomainServiceImpl.kt             # 도메인 서비스 구현체 (어댑터)
    dto/                             # DTO 패키지 (필요시) 
      DomainRequestDto.kt
      DomainResponseDto.kt
  /config/                           # 인프라 관련 설정
    DatabaseConfig.kt
    ApiClientConfig.kt               # API 클라이언트 설정
  /common/                           # 공통 인프라 유틸리티
    WebClientFactory.kt              # 웹 클라이언트 팩토리 등
```

## 3. 레포지토리 구현 (Repository Implementation)

### 3.1 기본 구조

```kotlin
@Repository
class UserRepositoryImpl(
    private val userJpaRepository: UserJpaRepository
) : UserRepository {
    // 메서드 구현
}
```

### 3.2 레포지토리 설계 원칙

1. **인터페이스 구현**: 도메인 레이어에 정의된 레포지토리 인터페이스를 구현
2. **기술 독립성**: 도메인 모델을 인프라스트럭처 기술(JPA 등)로부터 독립적으로 유지
3. **매핑 책임**: 영속성 모델(JPA 엔티티)과 도메인 모델 간 매핑 처리
4. **예외 변환**: 인프라스트럭처 예외를 도메인 예외로 변환
5. **트랜잭션 관리 없음**: 트랜잭션 관리는 애플리케이션 레이어에서 담당

### 3.3 매핑 전략

인프라스트럭처 레이어에서는 도메인 모델과 영속성 모델(JPA 엔티티 등) 간의 매핑을 담당합니다. 이때 다음 전략을 고려합니다:

1. **매퍼 클래스 분리**: 복잡한 매핑 로직은 별도의 매퍼 클래스로 분리
2. **직접 변환 메소드**: 간단한 매핑은 엔티티에 직접 변환 메소드 구현
3. **변환 메소드 명명 규칙**: 영속성 엔티티에는 다음과 같은 변환 메소드 명명 규칙을 사용
   - `from(domain)`: 도메인 모델을 받아 JPA 엔티티로 변환
   - `to()`: JPA 엔티티를 도메인 모델로 변환
4. **값 객체 매핑**: 값 객체는 Embeddable로 관리하고 적절한 변환 로직 제공

매핑 전략에 대한 자세한 예시는 [4. JPA 엔티티](#4-jpa-엔티티-jpa-entity) 섹션을 참고하세요.

## 4. JPA 엔티티 (JPA Entity)

### 4.1 기본 구조

```kotlin
@Entity
@Table(name = "users")
class UserJpaEntity(
    @Id
    @Column(name = "user_id")
    val userId: String,
    
    @Column(name = "created_at")
    val createdAt: LocalDateTime,
    
    @Column(name = "updated_at")
    var updatedAt: LocalDateTime
) {
    companion object {
        fun from(domain: User): UserJpaEntity {
            return UserJpaEntity(
                userId = domain.userId,
                createdAt = domain.createdAt,
                updatedAt = domain.updatedAt
            )
        }
    }

    fun to(): User {
        return User(
            userId = this.userId,
            createdAt = this.createdAt,
            updatedAt = this.updatedAt
        )
    }
}
```

### 4.2 JPA 엔티티 설계 원칙

1. **명확한 네이밍**: 클래스명에 JpaEntity 접미사 사용
2. **테이블명 명시**: @Table 어노테이션으로 테이블명 명시 (복수형 권장)
3. **컬럼명 명시**: @Column 어노테이션으로 컬럼명 명시 (snake_case 권장)
4. **감사 필드 포함**: 생성일시와 수정일시 필드 포함
5. **값 객체 매핑**: 값 객체는 @Embeddable/@Embedded 활용
6. **관계 설정**: 강결합된 엔티티에만 연관관계 설정, 그 외에는 ID 참조 방식 선호 (세부사항은 4.3 JPA 연관관계 설계 지침 참조)
7. **인덱스 정의**: 필요한 인덱스는 @Index로 명시
8. **Nullability 설정**: 기본적으로 모든 필드는 null을 허용하지 않음(`nullable = false`), nullable인 경우에만 명시적으로 지정
   ```kotlin
   // 기본적으로 null을 허용하지 않는 필드
   @Column(name = "username")  // nullable = false가 기본값이므로 생략 가능
   val username: String
   
   // null을 허용하는 필드
   @Column(name = "middle_name", nullable = true)
   val middleName: String?
   ```

### 4.3 JPA 연관관계 설계 지침

1. **연관관계 최소화**: 강결합된 엔티티가 아닌 경우 @OneToMany, @ManyToOne 등의 연관관계 사용을 지양하고 ID 참조 방식 선호
   - 이유: 연관관계는 객체 그래프 탐색을 편리하게 하지만, 성능 이슈(N+1 문제 등)와 복잡성을 증가시킬 수 있음
   - 예외: 주문-주문상품과 같이 라이프사이클이 완전히 동일하고 항상 함께 조회/수정되는 강결합 관계

4. **강결합 판단 기준**:
   - 항상 함께 생성/수정/삭제되는가?
   - 독립적으로 존재할 수 있는가?
   - 항상 함께 조회되는가?
   - 트랜잭션 경계가 동일한가?

## 5. Spring Data JPA 저장소 (Spring Data JPA Repository)

### 5.1 기본 구조

```kotlin
@Repository
interface UserJpaRepository : JpaRepository<UserJpaEntity, String> {
    // 쿼리 메서드 추가
}
```

### 5.2 JPA 저장소 설계 원칙

1. **네이밍 규칙**: 클래스명에 JpaRepository 접미사 사용
2. **쿼리 메서드**: 가능한 경우 쿼리 메서드 네이밍 규칙 활용
3. **쿼리 어노테이션**: 복잡한 쿼리는 @Query 어노테이션 활용
4. **페이징 지원**: 목록 조회 시 필요한 경우 페이징 기능 지원

## 6. 외부 API 클라이언트 (External API Client)

### 6.1 디렉토리 구조

인프라스트럭처 레이어는 JPA 저장소와 외부 API 클라이언트를 모두 포함합니다. 디렉토리 구조는 [2. 디렉토리 구조](#2-디렉토리-구조) 섹션에 정의된 구조를 따릅니다. 이 구조는 도메인별로 인프라스트럭처 컴포넌트를 명확하게 분리하면서도, 각 도메인 내에서는 단순한 구조를 유지합니다. 개발자는 특정 도메인의 모든 인프라스트럭처 구현체를 한 디렉토리에서 쉽게 찾을 수 있습니다.

### 6.2 API 클라이언트 설계 원칙

1. **도메인 중심**: 도메인별로 관련 API 클라이언트 구성
2. **인터페이스 분리**: 도메인 서비스와 독립적인 클라이언트 정의
3. **DTO 캡슐화**: 외부 API 요청/응답 DTO는 인프라 레이어 내부로 제한
4. **예외 변환**: 외부 API 예외를 도메인 예외로 변환
5. **재시도 정책**: 일시적 오류에 대한 재시도 정책 구현
6. **타임아웃 설정**: 적절한 타임아웃 설정으로 시스템 안정성 확보

### 6.3 API 클라이언트 구현 예시

```kotlin
@Component
class PaymentApiClient(
    private val webClient: WebClient,
    private val appProperties: AppProperties
) {
    fun processPayment(request: PaymentRequestDto): PaymentResponseDto {
        try {
            return webClient.post()
                .uri("${appProperties.payment.baseUrl}/payments")
                .bodyValue(request)
                .retrieve()
                .bodyToMono(PaymentResponseDto::class.java)
                .block() ?: throw PaymentException("결제 응답 없음")
        } catch (e: Exception) {
            throw PaymentException("결제 처리 실패: ${e.message}", e)
        }
    }
}
```

### 6.4 도메인 서비스 어댑터 예시

```kotlin
@Service
class PaymentServiceImpl(
    private val paymentApiClient: PaymentApiClient,
    private val paymentRepository: PaymentRepository
) : PaymentService {
    override fun processPayment(payment: Payment): PaymentResult {
        // API 요청 데이터 변환
        val requestDto = PaymentRequestDto.from(payment)
        
        // API 호출 및 응답 변환
        val responseDto = paymentApiClient.processPayment(requestDto)
        val result = responseDto.toPaymentResult()
        
        // 결과 저장 및 반환
        paymentRepository.save(payment.withResult(result))
        return result
    }
}
```

### 6.5 API 클라이언트 설정 예시

```kotlin
@Configuration
class ApiClientConfig {
    @Bean
    fun paymentWebClient(builder: WebClient.Builder, appProperties: AppProperties): WebClient {
        return builder
            .baseUrl(appProperties.payment.baseUrl)
            .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
            .codecs { configurer -> configurer.defaultCodecs().maxInMemorySize(2 * 1024 * 1024) }
            .build()
    }
}
```

### 6.6 API 응답 캐싱 전략

1. **캐시 적용 대상**: 자주 호출되고 데이터 변경이 적은 API
2. **캐시 정책**: TTL(Time-To-Live) 및 캐시 무효화 전략 정의
3. **캐시 구현**: Redis, Caffeine 등 적절한 캐시 솔루션 활용

## 7. 구현 예시 (Implementation Examples)

### 7.1 레포지토리만 사용하는 도메인 예시 (User 도메인)

#### 디렉토리 구조
```
/infrastructure
  /user/
    UserJpaRepository.kt
    UserJpaEntity.kt
    UserRepositoryImpl.kt
```

#### UserJpaEntity.kt
```kotlin
@Entity
@Table(name = "users")
class UserJpaEntity(
    @Id
    @Column(name = "user_id")
    val userId: String,
    
    @Column(name = "username")
    val username: String,
    
    @Column(name = "email")
    val email: String,
    
    @Column(name = "created_at")
    val createdAt: LocalDateTime
) {
    companion object {
        fun from(domain: User): UserJpaEntity {
            return UserJpaEntity(
                userId = domain.userId,
                username = domain.username,
                email = domain.email,
                createdAt = domain.createdAt
            )
        }
    }

    fun to(): User {
        return User(
            userId = this.userId,
            username = this.username,
            email = this.email,
            createdAt = this.createdAt
        )
    }
}
```

#### UserJpaRepository.kt
```kotlin
@Repository
interface UserJpaRepository : JpaRepository<UserJpaEntity, String> {
    fun findByEmail(email: String): UserJpaEntity?
}
```

#### UserRepositoryImpl.kt
```kotlin
@Repository
class UserRepositoryImpl(
    private val userJpaRepository: UserJpaRepository
) : UserRepository {
    override fun findById(userId: String): User? {
        return userJpaRepository.findById(userId).orElse(null)?.to()
    }
    
    override fun findByEmail(email: String): User? {
        return userJpaRepository.findByEmail(email)?.to()
    }
    
    override fun save(user: User): User {
        val savedEntity = userJpaRepository.save(UserJpaEntity.from(user))
        return savedEntity.to()
    }
}
```

### 7.2 외부 API만 사용하는 도메인 예시 (Payment 도메인)

#### 디렉토리 구조
```
/infrastructure
  /payment/
    PaymentApiClient.kt
    PaymentServiceImpl.kt
    dto/
      PaymentRequestDto.kt
      PaymentResponseDto.kt
```

#### PaymentRequestDto.kt
```kotlin
data class PaymentRequestDto(
    val orderId: String,
    val amount: BigDecimal,
    val currency: String,
    val cardToken: String
) {
    companion object {
        fun from(payment: Payment): PaymentRequestDto {
            return PaymentRequestDto(
                orderId = payment.orderId,
                amount = payment.amount,
                currency = payment.currency,
                cardToken = payment.cardToken
            )
        }
    }
}
```

#### PaymentResponseDto.kt
```kotlin
data class PaymentResponseDto(
    val paymentId: String,
    val status: String,
    val transactionId: String,
    val processingDate: String
) {
    fun toPaymentResult(): PaymentResult {
        return PaymentResult(
            paymentId = this.paymentId,
            status = PaymentStatus.valueOf(this.status),
            transactionId = this.transactionId,
            processingDate = LocalDateTime.parse(this.processingDate)
        )
    }
}
```

#### PaymentApiClient.kt
```kotlin
@Component
class PaymentApiClient(
    private val webClient: WebClient,
    private val appProperties: AppProperties
) {
    fun processPayment(request: PaymentRequestDto): PaymentResponseDto {
        try {
            return webClient.post()
                .uri("${appProperties.payment.baseUrl}/payments")
                .bodyValue(request)
                .retrieve()
                .bodyToMono(PaymentResponseDto::class.java)
                .block() ?: throw PaymentException("결제 응답 없음")
        } catch (e: Exception) {
            throw PaymentException("결제 처리 실패: ${e.message}", e)
        }
    }
}
```

#### PaymentServiceImpl.kt
```kotlin
@Service
class PaymentServiceImpl(
    private val paymentApiClient: PaymentApiClient
) : PaymentService {
    override fun processPayment(payment: Payment): PaymentResult {
        val requestDto = PaymentRequestDto.from(payment)
        val responseDto = paymentApiClient.processPayment(requestDto)
        return responseDto.toPaymentResult()
    }
}
```

### 7.3 레포지토리와 외부 API를 모두 사용하는 도메인 예시 (Order 도메인)

#### 디렉토리 구조
```
/infrastructure
  /order/
    OrderJpaRepository.kt
    OrderJpaEntity.kt
    OrderRepositoryImpl.kt
    OrderApiClient.kt
    OrderProcessorImpl.kt
    dto/
      ShippingRequestDto.kt
      ShippingResponseDto.kt
```

#### OrderJpaEntity.kt 및 OrderRepositoryImpl.kt
```kotlin
// JPA 엔티티 및 레포지토리 구현 (7.1의 User 예시와 유사)
```

#### OrderApiClient.kt
```kotlin
@Component
class OrderApiClient(
    private val webClient: WebClient,
    private val appProperties: AppProperties
) {
    fun requestShipping(request: ShippingRequestDto): ShippingResponseDto {
        try {
            return webClient.post()
                .uri("${appProperties.shipping.baseUrl}/shipping")
                .bodyValue(request)
                .retrieve()
                .bodyToMono(ShippingResponseDto::class.java)
                .block() ?: throw OrderException("배송 요청 응답 없음")
        } catch (e: Exception) {
            throw OrderException("배송 요청 실패: ${e.message}", e)
        }
    }
}
```

#### OrderProcessorImpl.kt
```kotlin
@Service
class OrderProcessorImpl(
    private val orderRepository: OrderRepository,
    private val orderApiClient: OrderApiClient
) : OrderProcessor {
    override fun processOrder(order: Order): Order {
        // 1. 주문 저장
        val savedOrder = orderRepository.save(order)
        
        // 2. 배송 요청
        val shippingRequest = ShippingRequestDto.from(savedOrder)
        val shippingResponse = orderApiClient.requestShipping(shippingRequest)
        
        // 3. 배송 정보로 주문 업데이트
        val updatedOrder = savedOrder.withShippingInfo(
            shippingResponse.toShippingInfo()
        )
        
        // 4. 업데이트된 주문 저장 및 반환
        return orderRepository.save(updatedOrder)
    }
}
```

