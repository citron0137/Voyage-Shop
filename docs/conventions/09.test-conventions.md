# 09. 테스트 컨벤션

## 1. 개요

본 문서는 Voyage-Shop 애플리케이션의 테스트 작성 시 일관성을 유지하고, 테스트 품질을 향상시키기 위한 기본 규약을 정의합니다. 모든 개발자는 본 규약을 숙지하고 준수하는 것을 원칙으로 합니다.

이 문서는 모든 레이어의 테스트에 공통적으로 적용되는 규약을 다루며, 레이어별 특화된 테스트 규약은 다음 문서를 참조하세요:

- [2. 도메인 레이어 유닛 테스트 컨벤션](./domain-layer-unit-test.md)
- [3. 애플리케이션 레이어 유닛 테스트 컨벤션](./application-layer-unit-test.md)
- [4. 애플리케이션 레이어 통합 테스트 컨벤션](./application-layer-integration-test.md)
- [5. 컨트롤러 레이어 테스트 컨벤션](./controller-layer-test.md)

## 2. 테스트 구조

### 2.1 패키지 구조
```
src/test/kotlin/kr/hhplus/be/server/
├── ServerApplicationTests.kt     # 스프링 부트 애플리케이션 컨텍스트 로드 테스트
├── TestcontainersConfiguration.kt # 테스트 컨테이너 설정
├── controllers/                  # 컨트롤러 레이어 테스트
│   ├── unit/                    # 컨트롤러 단위 테스트
│   └── integration/             # API 통합 테스트
├── application/                  # 애플리케이션 레이어 테스트
│   ├── unit/                    # 애플리케이션 단위 테스트
│   └── integration/             # 애플리케이션 통합 테스트
├── domain/                       # 도메인 레이어 테스트
│   └── unit/                    # 도메인 단위 테스트
└── infrastructure/               # 인프라스트럭처 레이어 테스트
    ├── repository/              # 레포지토리 테스트
    └── client/                  # 외부 클라이언트 테스트
```

### 2.2 기본 테스트 구조

모든 테스트는 Given-When-Then 패턴을 따라 구성합니다:

```kotlin
@Test
@DisplayName("테스트 설명")
fun testMethod() {
    // given: 테스트 사전 조건 설정
    
    // when: 테스트 대상 메서드 실행
    
    // then: 결과 검증
}
```

## 3. 네이밍 규칙

### 3.1 클래스 네이밍 공통 규칙

- 단위 테스트: `{대상클래스명}Test` (예: `UserServiceTest`)
- 통합 테스트: `{대상클래스명}IntegrationTest` (예: `UserRepositoryIntegrationTest`)
- API 테스트: `{도메인명}ApiTest` (예: `UserApiTest`)

각 레이어별 세부 네이밍 규칙은 해당 레이어의 테스트 컨벤션 문서를 참조하세요.

### 3.2 메서드 네이밍 공통 규칙

테스트 메소드명은 모두 영어로 작성하고, `@DisplayName`으로 한글 제목을 지정합니다:

```kotlin
@Test
@DisplayName("사용자 등록이 성공적으로 완료되어야 한다")
fun registerUserSuccessfully() {
    // 테스트 코드
}
```

메서드 이름은 다음 패턴 중 하나를 따릅니다:

1. `{테스트대상행위}_{조건}_{기대결과}` 형식
   - 예: `findUser_withValidId_returnsUserInfo`

2. `{테스트대상행위}Test` 형식 (간단한 테스트)
   - 예: `createOrderTest`

3. BDD 스타일 (should/when/given)
   - 예: `shouldCreateOrderWhenProductIsAvailable`

## 4. 테스트 독립성

### 4.1 독립성 원칙

모든 테스트는 독립적으로 실행 가능해야 합니다:

1. **상태 공유 없음**: 테스트 간 상태를 공유하지 않도록 설계
2. **테스트 순서 의존성 없음**: 테스트 실행 순서에 의존하지 않도록 구현
3. **외부 의존성 격리**: 가능한 외부 시스템에 의존하지 않도록 설계

### 4.2 테스트 데이터 관리

테스트 데이터는 다음 원칙에 따라 관리합니다:

1. **테스트 클래스 내 생성**: 가능한 테스트 메서드 내에서 모든 테스트 데이터 생성
2. **공통 데이터 팩토리**: 반복적으로 사용되는 테스트 데이터는 팩토리 메서드로 제공
3. **불변 테스트 데이터**: 테스트 데이터는 불변으로 설계하여 부작용 방지

```kotlin
// 공통 테스트 데이터 팩토리 메서드 예시
private fun createSampleUser(userId: String = "user1"): User {
    return User(userId, "user1@example.com", LocalDateTime.now(), LocalDateTime.now())
}
```

## 5. Mock 사용 원칙

### 5.1 Mock 라이브러리

테스트에서 Mock 객체가 필요한 경우 Mockk 라이브러리를 사용합니다:

```kotlin
@Test
fun someTest() {
    // given
    val mockService = mockk<SomeService>()
    
    every { mockService.doSomething(any()) } returns "result"
    
    // when
    val result = mockService.doSomething("input")
    
    // then
    assertEquals("result", result)
    verify { mockService.doSomething("input") }
}
```

### 5.2 Mock 사용 범위

각 레이어별 Mock 사용 범위는 해당 레이어의 테스트 컨벤션 문서를 참조하세요.

## 6. 예외 테스트

### 6.1 예외 테스트 패턴

예외 테스트는 다음 패턴 중 하나를 사용합니다:

1. **assertThrows 사용** (권장):
   ```kotlin
   @Test
   @DisplayName("잘못된 입력 시 예외가 발생해야 한다")
   fun invalidInput_shouldThrowException() {
       // given
       val invalidInput = "invalid-input"
       
       // when & then
       val exception = assertThrows<IllegalArgumentException> {
           service.process(invalidInput)
       }
       
       // 예외 메시지 검증 (필요한 경우)
       assertEquals("입력값이 유효하지 않습니다", exception.message)
   }
   ```

2. **try-catch 패턴**:
   ```kotlin
   @Test
   @DisplayName("잘못된 입력 시 예외가 발생해야 한다")
   fun invalidInput_shouldThrowException() {
       // given
       val invalidInput = "invalid-input"
       
       try {
           // when
           service.process(invalidInput)
           
           // then
           fail("예외가 발생해야 합니다")
       } catch (e: IllegalArgumentException) {
           // 예외 발생이 기대하는 동작
           assertEquals("입력값이 유효하지 않습니다", e.message)
       }
   }
   ```

### 6.2 예외 테스트 네이밍

예외 테스트 메서드 이름은 예외 상황을 명확히 표현해야 합니다:

- `{메서드명}_with{조건}_shouldThrow{예외타입}` 패턴 권장
- 예: `createUser_withInvalidEmail_shouldThrowIllegalArgumentException`

## 7. 테스트 가독성

### 7.1 가독성 향상 원칙

1. **명확한 단언문**: 의도가 명확한 단언문 사용
2. **의미 있는 변수명**: 변수명을 통해 테스트 의도 전달
3. **테스트 설명 주석**: 복잡한 테스트의 경우 설명 주석 추가
4. **과도한 검증 지양**: 테스트 의도와 관련 없는 검증은 지양

### 7.2 헬퍼 메서드 활용

복잡한 설정이나 검증 로직은 헬퍼 메서드로 분리하여 가독성을 높입니다:

```kotlin
@Test
@DisplayName("주문 취소 시 모든 주문 상품이 취소됨")
fun cancelOrder_shouldCancelAllOrderItems() {
    // given
    val order = createOrderWithMultipleItems()
    
    // when
    order.cancel()
    
    // then
    assertAllItemsCanceled(order)
}

private fun createOrderWithMultipleItems(): Order {
    // 여러 상품이 있는 주문 생성 로직
}

private fun assertAllItemsCanceled(order: Order) {
    order.items.forEach {
        assertTrue(it.isCanceled)
    }
}
```

## 8. 공통 설정 패턴

### 8.1 스프링 테스트 설정

스프링 애플리케이션을 테스트할 때는 다음 설정 패턴을 활용합니다:

```kotlin
@SpringBootTest
@Import(TestcontainersConfiguration::class) // 필요한 경우
class SomeIntegrationTest {
    // 테스트 코드
}
```

### 8.2 데이터베이스 테스트 설정

데이터베이스 관련 테스트는 Testcontainers를 활용하여 설정합니다:

```kotlin
@Configuration
class TestcontainersConfiguration {
    companion object {
        val container = PostgreSQLContainer<Nothing>("postgres:15-alpine").apply {
            withDatabaseName("testdb")
            withUsername("test")
            withPassword("test")
        }

        init {
            container.start()
        }
    }

    @Bean
    @Primary
    fun dataSource(): DataSource {
        val config = HikariConfig()
        config.jdbcUrl = container.jdbcUrl
        config.username = container.username
        config.password = container.password
        config.driverClassName = container.driverClassName
        return HikariDataSource(config)
    }
}
```

## 9. 파라미터화 테스트 활용

다양한 입력에 대해 동일한 검증이 필요한 경우 JUnit5의 파라미터화 테스트를 활용합니다:

```kotlin
@ParameterizedTest
@DisplayName("다양한 입력 검증")
@MethodSource("inputProvider")
fun validateMultipleInputs(testCase: TestCase) {
    // given
    val input = testCase.input
    
    // when
    val result = service.process(input)
    
    // then
    assertEquals(testCase.expected, result)
}

private data class TestCase(
    val description: String,
    val input: String,
    val expected: String
)

private fun inputProvider() = Stream.of(
    TestCase("정상 입력", "valid-input", "expected-result"),
    TestCase("경계값 입력", "boundary-input", "boundary-result"),
    TestCase("특수 문자 입력", "special-input#$%", "special-result")
)
```

## 10. 테스트 커버리지

### 10.1 커버리지 목표

Voyage-Shop 프로젝트의 전체 테스트 커버리지 목표는 다음과 같습니다:

1. **클래스 커버리지**: 85% 이상
2. **메서드 커버리지**: 80% 이상
3. **라인 커버리지**: 75% 이상

각 레이어별 커버리지 목표는 해당 레이어의 테스트 컨벤션 문서를 참조하세요.

### 10.2 테스트 우선순위

테스트 우선순위는 다음과 같습니다:

1. **핵심 비즈니스 규칙**: 가장 높은 우선순위로 테스트
2. **복잡한 로직**: 다양한 조건과 분기가 있는 복잡한 로직 집중 테스트
3. **경계 조건**: 경계값 및 예외 케이스 테스트

## 11. 테스트 유틸리티

### 11.1 공통 테스트 유틸리티

자주 사용되는 테스트 유틸리티는 별도의 클래스로 제공합니다:

```kotlin
/**
 * 테스트용 유틸리티 클래스
 */
object TestUtils {
    fun createLocalDateTime(year: Int, month: Int, day: Int, hour: Int = 0, minute: Int = 0): LocalDateTime {
        return LocalDateTime.of(year, month, day, hour, minute)
    }
    
    fun createRandomString(length: Int): String {
        return UUID.randomUUID().toString().take(length)
    }
    
    fun createRandomEmail(): String {
        return "${createRandomString(8)}@example.com"
    }
}
```

## 12. 통합을 위한 팁

1. **중복 최소화**: 공통 설정과 헬퍼 메서드를 추상 클래스로 추출
2. **데이터 독립성**: 각 테스트가 독립적으로 실행될 수 있도록 테스트 데이터 관리
3. **문서화**: 복잡한 테스트의 경우 주석과 `@DisplayName`을 통해 의도 명확히 작성
4. **CI/CD 통합**: 테스트가 CI/CD 파이프라인에서 자동으로 실행되도록 설정 