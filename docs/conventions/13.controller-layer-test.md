# 13. 컨트롤러 레이어 테스트 컨벤션

## 1. 개요

본 문서는 Voyage-Shop 애플리케이션의 컨트롤러 레이어 테스트 작성 시 일관성을 유지하고, 테스트 품질을 향상시키기 위한 규약을 정의합니다. 이 문서는 [1. 테스트 컨벤션](./test-conventions.md)을 기반으로 합니다. 공통 규약은 해당 문서를 참조하세요.

컨트롤러 레이어 테스트의 목적은 API 엔드포인트가 올바르게 작동하는지 검증하는 것입니다. 이는 HTTP 요청의 올바른 처리, 파라미터 유효성 검사, 적절한 응답 및 상태 코드 반환 등을 포함합니다.

## 2. 테스트 종류

컨트롤러 테스트는 다음 두 가지 유형으로 구분합니다:

1. **단위 테스트**: 컨트롤러의 비즈니스 로직을 Mock 객체를 사용하여 테스트
2. **통합 테스트**: Spring MVC Test를 사용한 엔드포인트 전체 테스트

## 3. 테스트 디렉토리 구조

```
src/test/kotlin/kr/hhplus/be/server/
└── controllers/                 # 컨트롤러 테스트
    ├── unit/                    # 단위 테스트
    │   ├── UserControllerTest.kt    # 사용자 컨트롤러 단위 테스트
    │   └── OrderControllerTest.kt   # 주문 컨트롤러 단위 테스트
    └── integration/             # 통합 테스트
        ├── UserApiTest.kt           # 사용자 API 통합 테스트
        └── OrderApiTest.kt          # 주문 API 통합 테스트
```

## 4. 테스트 네이밍 규칙

### 4.1 클래스 네이밍

- 단위 테스트: `{컨트롤러명}Test` (예: `UserControllerTest`)
- 통합 테스트: `{도메인명}ApiTest` (예: `UserApiTest`)

### 4.2 메서드 네이밍

[1. 테스트 컨벤션](./test-conventions.md)의 메서드 네이밍 규칙을 따르되, 컨트롤러 레이어에서는 다음 패턴을 권장합니다:

1. HTTP 메서드, API 이름, 상황 및 결과 조합:
   - 예: `postUserValidInputSuccessTest`, `getUserNotFoundTest`

2. 테스트 시나리오 설명:
   - 예: `registerUserWithInvalidEmailReturnsBadRequestTest`

## 5. 단위 테스트

### 5.1 기본 설정

컨트롤러 단위 테스트는 다음 어노테이션을 기본으로 사용합니다:

```kotlin
@ExtendWith(MockKExtension::class)
class UserControllerTest {
    @MockK
    private lateinit var userFacade: UserFacade
    
    @InjectMockKs
    private lateinit var userController: UserController
    
    private lateinit var objectMapper: ObjectMapper
    
    @BeforeEach
    fun setUp() {
        objectMapper = ObjectMapper().registerModule(JavaTimeModule())
    }
    
    // 테스트 코드
}
```

### 5.2 요청 및 응답 테스트

```kotlin
@Test
@DisplayName("유효한 사용자 등록 요청이 성공적으로 처리되어야 한다")
fun registerUserValidRequestTest() {
    // given
    val request = UserRequest.Register("test@example.com", "password123")
    val result = UserResult.Register("user1", "test@example.com")
    
    every { userFacade.registerUser(any()) } returns result
    
    // when
    val response = userController.registerUser(request)
    
    // then
    assertEquals(HttpStatus.CREATED, response.statusCode)
    assertNotNull(response.body)
    assertEquals("user1", response.body?.userId)
    assertEquals("test@example.com", response.body?.email)
    
    // 정확한 파라미터로 호출되었는지 검증
    verify { 
        userFacade.registerUser(match { 
            it.email == "test@example.com" && 
            it.password == "password123" 
        }) 
    }
}
```

### 5.3 예외 처리 테스트

```kotlin
@Test
@DisplayName("존재하지 않는 사용자 조회 시 404 상태를 반환해야 한다")
fun getUserNotFoundTest() {
    // given
    val userId = "non-existent-user"
    
    every { userFacade.getUser(any()) } throws UserNotFoundException("사용자를 찾을 수 없습니다")
    
    // when & then
    assertThrows<UserNotFoundException> {
        userController.getUser(userId)
    }
    
    // ControllerAdvice로 예외 처리되는 경우
    val controllerAdvice = GlobalExceptionHandler()
    val exception = UserNotFoundException("사용자를 찾을 수 없습니다")
    val response = controllerAdvice.handleUserNotFoundException(exception)
    
    assertEquals(HttpStatus.NOT_FOUND, response.statusCode)
    assertEquals("사용자를 찾을 수 없습니다", response.body?.message)
}
```

### 5.4 유효성 검사 테스트

```kotlin
@Test
@DisplayName("유효하지 않은 이메일로 사용자 등록 시 400 상태를 반환해야 한다")
fun registerUserInvalidEmailTest() {
    // given
    val request = UserRequest.Register("invalid-email", "password123")
    
    // ControllerAdvice + @Valid 조합 테스트
    // 실제 예외는 Spring MVC에서 발생하므로, 해당 예외를 시뮬레이션
    val controllerAdvice = GlobalExceptionHandler()
    val bindingResult = BindingResult.create()
    bindingResult.addError(FieldError("userRequest", "email", "올바른 이메일 형식이 아닙니다"))
    
    val exception = MethodArgumentNotValidException(
        MethodParameter(UserController::class.java.getDeclaredMethod("registerUser", UserRequest.Register::class.java), 0),
        bindingResult
    )
    
    // when
    val response = controllerAdvice.handleValidationException(exception)
    
    // then
    assertEquals(HttpStatus.BAD_REQUEST, response.statusCode)
    assertTrue(response.body?.message?.contains("올바른 이메일 형식이 아닙니다") ?: false)
}
```

## 6. 통합 테스트

### 6.1 기본 설정

API 통합 테스트는 다음 어노테이션을 기본으로 사용합니다:

```kotlin
@SpringBootTest
@AutoConfigureMockMvc
@Import(TestcontainersConfiguration::class)
class UserApiTest {
    @Autowired
    private lateinit var mockMvc: MockMvc
    
    @Autowired
    private lateinit var objectMapper: ObjectMapper
    
    // 테스트용 데이터 생성 및 관련 서비스
    @Autowired
    private lateinit var userRepository: UserRepository
    
    @BeforeEach
    fun setUp() {
        // 테스트 데이터 초기화
        userRepository.deleteAll()
    }
    
    // 테스트 코드
}
```

### 6.2 기본 API 테스트

```kotlin
@Test
@DisplayName("사용자 등록 API가 올바르게 작동해야 한다")
fun registerUserApiTest() {
    // given
    val request = UserRequest.Register("test@example.com", "password123")
    
    // when
    val result = mockMvc.perform(
        post("/api/v1/users")
            .contentType(MediaType.APPLICATION_JSON)
            .content(objectMapper.writeValueAsString(request))
    )
    
    // then
    result
        .andExpect(status().isCreated)
        .andExpect(jsonPath("$.userId").exists())
        .andExpect(jsonPath("$.email").value("test@example.com"))
        
    // DB에 저장되었는지 검증
    val savedUser = userRepository.findByEmail("test@example.com")
    assertNotNull(savedUser)
}
```

### 6.3 인증/인가 테스트

```kotlin
@Test
@DisplayName("인증되지 않은 요청은 401 상태를 반환해야 한다")
fun unauthenticatedRequestTest() {
    // when
    val result = mockMvc.perform(
        get("/api/v1/users/me")
            // 인증 헤더 없음
    )
    
    // then
    result.andExpect(status().isUnauthorized)
}

@Test
@DisplayName("인증된 요청은 사용자 정보에 접근할 수 있어야 한다")
@WithMockUser(username = "user1")
fun authenticatedRequestTest() {
    // given
    userRepository.save(User("user1", "user1@example.com", "hashed_password", LocalDateTime.now(), LocalDateTime.now()))
    
    // when
    val result = mockMvc.perform(
        get("/api/v1/users/me")
    )
    
    // then
    result
        .andExpect(status().isOk)
        .andExpect(jsonPath("$.userId").value("user1"))
}

@Test
@DisplayName("권한이 없는 요청은 403 상태를 반환해야 한다")
@WithMockUser(username = "user1", roles = ["USER"])
fun unauthorizedRequestTest() {
    // when
    val result = mockMvc.perform(
        get("/api/v1/admin/users")
    )
    
    // then
    result.andExpect(status().isForbidden)
}
```

### 6.4 요청 파라미터 테스트

```kotlin
@Test
@DisplayName("유효하지 않은 요청 파라미터는 400 상태를 반환해야 한다")
fun invalidRequestParameterTest() {
    // when
    val result = mockMvc.perform(
        get("/api/v1/products")
            .param("page", "-1")  // 음수 페이지
            .param("size", "1000") // 너무 큰 페이지 크기
    )
    
    // then
    result
        .andExpect(status().isBadRequest)
        .andExpect(jsonPath("$.message").exists())
}

@Test
@DisplayName("경로 변수가 유효하지 않으면 400 상태를 반환해야 한다")
fun invalidPathVariableTest() {
    // when
    val result = mockMvc.perform(
        get("/api/v1/products/{productId}", "invalid-id")
    )
    
    // then
    result.andExpect(status().isBadRequest)
}
```

### 6.5 요청 본문 테스트

```kotlin
@Test
@DisplayName("유효하지 않은 요청 본문은 400 상태를 반환해야 한다")
fun invalidRequestBodyTest() {
    // given
    val invalidRequest = """{"email": "invalid-email", "password": ""}"""
    
    // when
    val result = mockMvc.perform(
        post("/api/v1/users")
            .contentType(MediaType.APPLICATION_JSON)
            .content(invalidRequest)
    )
    
    // then
    result
        .andExpect(status().isBadRequest)
        .andExpect(jsonPath("$.message").exists())
}
```

### 6.6 페이징 및 정렬 테스트

```kotlin
@Test
@DisplayName("페이징 및 정렬 파라미터가 올바르게 처리되어야 한다")
fun paginationAndSortingTest() {
    // given
    // 테스트 데이터 생성
    for (i in 1..20) {
        productRepository.save(Product("product$i", "상품 $i", i * 1000, 100))
    }
    
    // when
    val result = mockMvc.perform(
        get("/api/v1/products")
            .param("page", "1")       // 두 번째 페이지
            .param("size", "5")       // 페이지당 5개
            .param("sort", "price,desc") // 가격 내림차순
    )
    
    // then
    result
        .andExpect(status().isOk)
        .andExpect(jsonPath("$.totalElements").value(20))
        .andExpect(jsonPath("$.totalPages").value(4))
        .andExpect(jsonPath("$.content").isArray)
        .andExpect(jsonPath("$.content.length()").value(5))
        .andExpect(jsonPath("$.content[0].price").value(20000)) // 두 번째 페이지, 첫 번째 항목 가격
}
```

### 6.7 파일 업로드 테스트

```kotlin
@Test
@DisplayName("이미지 파일 업로드가 성공해야 한다")
fun imageUploadTest() {
    // given
    val filename = "test-image.jpg"
    val fileContent = "test image content".toByteArray()
    
    // when
    val result = mockMvc.perform(
        multipart("/api/v1/products/{productId}/images", "product1")
            .file(MockMultipartFile("image", filename, "image/jpeg", fileContent))
    )
    
    // then
    result
        .andExpect(status().isOk)
        .andExpect(jsonPath("$.imageUrl").exists())
}

@Test
@DisplayName("허용되지 않는 파일 타입은 업로드가 거부되어야 한다")
fun invalidFileTypeUploadTest() {
    // given
    val filename = "test-script.js"
    val fileContent = "alert('test')".toByteArray()
    
    // when
    val result = mockMvc.perform(
        multipart("/api/v1/products/{productId}/images", "product1")
            .file(MockMultipartFile("image", filename, "application/javascript", fileContent))
    )
    
    // then
    result.andExpect(status().isBadRequest)
}
```

### 6.8 응답 형식 및 헤더 테스트

```kotlin
@Test
@DisplayName("API 응답이 올바른 형식과 헤더를 포함해야 한다")
fun responseFormatAndHeadersTest() {
    // given
    userRepository.save(User("user1", "user1@example.com", "hashed_password", LocalDateTime.now(), LocalDateTime.now()))
    
    // when
    val result = mockMvc.perform(
        get("/api/v1/users/{userId}", "user1")
    )
    
    // then
    result
        .andExpect(status().isOk)
        .andExpect(content().contentType(MediaType.APPLICATION_JSON))
        .andExpect(header().exists("X-Request-ID"))
        .andExpect(jsonPath("$.userId").value("user1"))
        .andExpect(jsonPath("$.email").value("user1@example.com"))
}
```

### 6.9 캐시 테스트

```kotlin
@Test
@DisplayName("캐시 헤더가 올바르게 설정되어야 한다")
fun cacheHeadersTest() {
    // when
    val result = mockMvc.perform(
        get("/api/v1/products")
    )
    
    // then
    result
        .andExpect(status().isOk)
        .andExpect(header().string("Cache-Control", containsString("max-age=")))
}
```

## 7. 보안 테스트

### 7.1 XSS 방지 테스트

```kotlin
@Test
@DisplayName("XSS 공격 시도가 방어되어야 한다")
fun xssAttackPreventionTest() {
    // given
    val maliciousContent = """{"name": "<script>alert('xss')</script>"}"""
    
    // when
    val result = mockMvc.perform(
        post("/api/v1/reviews")
            .contentType(MediaType.APPLICATION_JSON)
            .content(maliciousContent)
    )
    
    // then
    result.andExpect(status().isOk)
    
    // 응답에 스크립트 태그가 이스케이프 처리되었는지 검증
    val response = result.andReturn().response.contentAsString
    assertFalse(response.contains("<script>"))
    assertTrue(response.contains("&lt;script&gt;"))
}
```

### 7.2 CSRF 보호 테스트

```kotlin
@Test
@DisplayName("CSRF 토큰이 누락된 요청은 거부되어야 한다")
@WithMockUser
fun csrfProtectionTest() {
    // given
    val request = UserRequest.Register("test@example.com", "password123")
    
    // CSRF 설정 활성화
    mockMvc = MockMvcBuilders
        .webAppContextSetup(webApplicationContext)
        .apply(SecurityMockMvcConfigurers.springSecurity())
        .build()
    
    // when: CSRF 토큰 없이 요청
    val result = mockMvc.perform(
        post("/api/v1/users")
            .contentType(MediaType.APPLICATION_JSON)
            .content(objectMapper.writeValueAsString(request))
    )
    
    // then
    result.andExpect(status().isForbidden)
}
```

### 7.3 로그인 보안 테스트

```kotlin
@Test
@DisplayName("잘못된 로그인 시도가 올바르게 처리되어야 한다")
fun invalidLoginAttemptTest() {
    // given
    val loginRequest = """{"email": "user@example.com", "password": "wrong-password"}"""
    
    // when
    val result = mockMvc.perform(
        post("/api/v1/auth/login")
            .contentType(MediaType.APPLICATION_JSON)
            .content(loginRequest)
    )
    
    // then
    result.andExpect(status().isUnauthorized)
}

@Test
@DisplayName("유효한 로그인 시도는 토큰을 반환해야 한다")
fun validLoginAttemptTest() {
    // given
    val email = "user@example.com"
    val password = "correct-password"
    val encodedPassword = passwordEncoder.encode(password)
    
    userRepository.save(User("user1", email, encodedPassword, LocalDateTime.now(), LocalDateTime.now()))
    
    val loginRequest = """{"email": "$email", "password": "$password"}"""
    
    // when
    val result = mockMvc.perform(
        post("/api/v1/auth/login")
            .contentType(MediaType.APPLICATION_JSON)
            .content(loginRequest)
    )
    
    // then
    result
        .andExpect(status().isOk)
        .andExpect(jsonPath("$.token").exists())
        .andExpect(jsonPath("$.expiresIn").exists())
}
```

## 8. 문서화

API 테스트는 Spring REST Docs를 사용하여 문서화합니다:

```kotlin
@SpringBootTest
@AutoConfigureMockMvc
@AutoConfigureRestDocs(outputDir = "build/generated-snippets")
class UserApiDocumentationTest {
    @Autowired
    private lateinit var mockMvc: MockMvc
    
    @Autowired
    private lateinit var objectMapper: ObjectMapper
    
    @Test
    @DisplayName("사용자 등록 API 문서화")
    fun documentRegisterUser() {
        // given
        val request = UserRequest.Register("test@example.com", "password123")
        
        // when & then
        mockMvc.perform(
            post("/api/v1/users")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request))
        )
            .andExpect(status().isCreated)
            .andDo(
                document(
                    "register-user",
                    preprocessRequest(prettyPrint()),
                    preprocessResponse(prettyPrint()),
                    requestFields(
                        fieldWithPath("email").description("사용자 이메일"),
                        fieldWithPath("password").description("사용자 비밀번호")
                    ),
                    responseFields(
                        fieldWithPath("userId").description("생성된 사용자 ID"),
                        fieldWithPath("email").description("사용자 이메일")
                    )
                )
            )
    }
}
```

## 9. 성능 테스트

### 9.1 응답 시간 테스트

```kotlin
@Test
@DisplayName("API 응답 시간이 허용 가능한 범위 내에 있어야 한다")
fun apiResponseTimeTest() {
    // given
    val startTime = System.currentTimeMillis()
    
    // when
    mockMvc.perform(get("/api/v1/products"))
        .andExpect(status().isOk)
    
    // then
    val endTime = System.currentTimeMillis()
    val responseTime = endTime - startTime
    
    // 500ms 이내에 응답해야 함
    assertTrue(responseTime < 500, "API 응답 시간이 너무 깁니다: $responseTime ms")
}
```

### 9.2 부하 테스트

```kotlin
@Test
@DisplayName("동시 요청 처리 테스트")
fun concurrentRequestsTest() throws Exception {
    // given
    val threadCount = 10
    val executor = Executors.newFixedThreadPool(threadCount)
    val countDownLatch = CountDownLatch(threadCount)
    val exceptions = ConcurrentLinkedQueue<Exception>()
    val results = ConcurrentLinkedQueue<MvcResult>()
    
    // when
    for (i in 0 until threadCount) {
        executor.submit {
            try {
                val result = mockMvc.perform(get("/api/v1/products"))
                    .andReturn()
                results.add(result)
            } catch (e: Exception) {
                exceptions.add(e)
            } finally {
                countDownLatch.countDown()
            }
        }
    }
    
    // 모든 스레드 완료 대기
    countDownLatch.await(10, TimeUnit.SECONDS)
    
    // then
    assertTrue(exceptions.isEmpty(), "동시 요청 중 예외 발생: ${exceptions.firstOrNull()}")
    
    for (result in results) {
        assertEquals(200, result.response.status)
    }
}
```

## 10. 컨트롤러 테스트 유틸리티

### 10.1 인증 유틸리티

```kotlin
/**
 * 테스트용 인증 토큰 생성 유틸리티
 */
object TestAuthUtils {
    private val jwtSecret = "testSecret12345678901234567890123456789012"
    private val jwtExpiration = 3600000L
    
    fun generateToken(userId: String, roles: List<String> = listOf("ROLE_USER")): String {
        val now = Date()
        val expiryDate = Date(now.time + jwtExpiration)
        
        return Jwts.builder()
            .setSubject(userId)
            .claim("roles", roles)
            .setIssuedAt(now)
            .setExpiration(expiryDate)
            .signWith(Keys.hmacShaKeyFor(jwtSecret.toByteArray()))
            .compact()
    }
    
    fun getAuthHeader(userId: String, roles: List<String> = listOf("ROLE_USER")): String {
        return "Bearer ${generateToken(userId, roles)}"
    }
}
```

### 10.2 요청 빌더 유틸리티

```kotlin
/**
 * 테스트용 요청 빌더 유틸리티
 */
class RequestBuilderUtils {
    companion object {
        fun jsonRequest(method: HttpMethod, uri: String, content: Any): MockHttpServletRequestBuilder {
            val objectMapper = ObjectMapper().registerModule(JavaTimeModule())
            
            return MockMvcRequestBuilders
                .request(method, uri)
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(content))
        }
        
        fun authRequest(method: HttpMethod, uri: String, userId: String): MockHttpServletRequestBuilder {
            return MockMvcRequestBuilders
                .request(method, uri)
                .header("Authorization", TestAuthUtils.getAuthHeader(userId))
        }
    }
}
```

### 10.3 결과 검증 유틸리티

```kotlin
/**
 * 테스트 결과 검증 유틸리티
 */
object ResultVerificationUtils {
    fun verifySuccessResponse(result: ResultActions, expectedStatus: Int = 200): ResultActions {
        return result
            .andExpect(status().`is`(expectedStatus))
            .andExpect(jsonPath("$.success").value(true))
    }
    
    fun verifyErrorResponse(result: ResultActions, expectedStatus: Int = 400): ResultActions {
        return result
            .andExpect(status().`is`(expectedStatus))
            .andExpect(jsonPath("$.success").value(false))
            .andExpect(jsonPath("$.message").exists())
    }
    
    fun verifyPaginatedResponse(result: ResultActions, expectedPageSize: Int): ResultActions {
        return result
            .andExpect(status().isOk)
            .andExpect(jsonPath("$.content").isArray)
            .andExpect(jsonPath("$.content.length()").value(expectedPageSize))
            .andExpect(jsonPath("$.totalElements").exists())
            .andExpect(jsonPath("$.totalPages").exists())
            .andExpect(jsonPath("$.size").exists())
            .andExpect(jsonPath("$.number").exists())
    }
}
```

## 11. 테스트 커버리지

컨트롤러 레이어 테스트는 다음 수준의 커버리지를 목표로 합니다:

1. **엔드포인트 커버리지**: 100% (모든 API 엔드포인트에 대한 테스트)
2. **요청 유형 커버리지**: 90% 이상 (성공/실패 시나리오 모두 포함)
3. **응답 상태 코드 커버리지**: 90% 이상 (주요 상태 코드 모두 테스트)

이는 [공통 테스트 컨벤션](./test-conventions.md)에서 정의한 일반적인 커버리지 목표보다 더 엄격한 기준입니다.

## 12. 통합을 위한 팁

[공통 테스트 컨벤션](./test-conventions.md)의 통합 팁을 참조하되, 컨트롤러 테스트에 특화된 다음 팁을 추가로 적용합니다:

1. **API 계층 구분**: 퍼블릭 API와 내부 API를 구분하여 테스트 전략 다르게 적용
2. **시나리오 중심 테스트**: 사용자 시나리오 기반의 통합 테스트 구성
3. **경계 테스트 집중**: 입력값 검증, 인증/인가, 에러 처리 등 경계 조건에 대한 테스트 집중
4. **문서 동기화**: 테스트와 API 문서가 항상 동기화되도록 관리 