# 12. 애플리케이션 레이어 통합 테스트 컨벤션

## 1. 개요

본 문서는 Voyage-Shop 애플리케이션의 애플리케이션 레이어 통합 테스트 작성 시 일관성을 유지하고, 테스트 품질을 향상시키기 위한 규약을 정의합니다. 모든 개발자는 본 규약을 숙지하고 준수하는 것을 원칙으로 합니다.

애플리케이션 레이어 통합 테스트의 목적은 여러 도메인 서비스와 인프라스트럭처 컴포넌트를 포함한 전체 워크플로우가 올바르게 동작하는지 검증하는 것입니다. 이 테스트는 실제 데이터베이스와의 상호작용 및 트랜잭션 관리를 중점적으로 검증합니다.

## 2. 테스트 디렉토리 구조

```
src/test/kotlin/kr/hhplus/be/server/
└── integration/                # 통합 테스트
    ├── order/                  # 주문 관련 통합 테스트
    │   ├── OrderFlowIntegrationTest.kt        # 주문 흐름 통합 테스트
    │   └── CouponApplyIntegrationTest.kt      # 쿠폰 적용 통합 테스트
    ├── user/                   # 사용자 관련 통합 테스트
    │   └── UserRegistrationIntegrationTest.kt # 사용자 등록 통합 테스트
    └── ...                     # 기타 통합 테스트
```

## 3. 테스트 네이밍 규칙

### 3.1 클래스 네이밍

- 비즈니스 시나리오 기반: `{시나리오명}IntegrationTest` (예: `OrderCheckoutIntegrationTest`)
- 도메인 기반: `{도메인명}FlowIntegrationTest` (예: `UserRegistrationFlowIntegrationTest`)

### 3.2 메서드 네이밍

테스트 메소드명은 모두 영어로 작성하고, `@DisplayName`으로 한글 제목을 지정합니다.

```kotlin
@Test
@DisplayName("사용자 등록 후 포인트와 쿠폰이 정상적으로 지급되어야 한다")
fun registerUserWithWelcomePointsAndCouponTest() {
    // 테스트 코드
}
```

### 3.3 메서드 네이밍 패턴

메서드 이름은 다음 패턴을 따릅니다:

1. 테스트 시나리오 중심: `{테스트시나리오}Test` 형식 권장
   - 예: `orderWithCouponAndPointsTest`

2. 시나리오와 결과 조합:
   - 예: `registerUserAndVerifyWelcomeBenefitsTest`

## 4. 테스트 설정

### 4.1 기본 설정

모든 통합 테스트는 다음 어노테이션을 기본으로 사용합니다:

```kotlin
@SpringBootTest
@Import(TestcontainersConfiguration::class)
class OrderFlowIntegrationTest {
    // 테스트 코드
}
```

### 4.2 테스트컨테이너 설정

테스트컨테이너는 다음과 같이 설정합니다:

```kotlin
@Configuration
class TestcontainersConfiguration {
    companion object {
        private val postgreSQLContainer = PostgreSQLContainer<Nothing>("postgres:14.5").apply {
            withDatabaseName("testdb")
            withUsername("test")
            withPassword("test")
            withReuse(true)
        }
        
        init {
            postgreSQLContainer.start()
        }
    }
    
    @Bean
    fun dataSourceProperties(): DataSourceProperties {
        return DataSourceProperties().apply {
            url = postgreSQLContainer.jdbcUrl
            username = postgreSQLContainer.username
            password = postgreSQLContainer.password
        }
    }
}
```

### 4.3 테스트 데이터 클리어

각 테스트 실행 전에 테스트 데이터를 클리어합니다:

```kotlin
@Autowired
private lateinit var jdbcTemplate: JdbcTemplate

@BeforeEach
fun setUp() {
    // 테이블 데이터 클리어
    jdbcTemplate.execute("DELETE FROM orders")
    jdbcTemplate.execute("DELETE FROM order_items")
    jdbcTemplate.execute("DELETE FROM user_points")
    jdbcTemplate.execute("DELETE FROM users")
}
```

## 5. 테스트 트랜잭션 관리

### 5.1 트랜잭션 어노테이션

통합 테스트에서 트랜잭션 관리 방식은 테스트 목적에 따라 선택합니다:

1. **롤백 테스트 (기본)**: 테스트 메서드 실행 후 자동 롤백
```kotlin
@Transactional
@Test
@DisplayName("주문 생성 테스트")
fun createOrderTest() {
    // 테스트 코드
}
```

2. **커밋 테스트**: 실제 커밋이 필요한 경우
```kotlin
@Rollback(false)
@Test
@DisplayName("주문 생성 후 데이터 유지 필요 테스트")
fun createOrderAndKeepDataTest() {
    // 테스트 코드
}
```

### 5.2 트랜잭션 전파 행동 테스트

트랜잭션 전파 행동을 테스트할 때는 직접 TransactionTemplate을 사용합니다:

```kotlin
@Autowired
private lateinit var transactionTemplate: TransactionTemplate

@Test
@DisplayName("포인트 차감 실패 시 주문 생성도 롤백되어야 한다")
fun pointDeductionFailureRollbacksOrderCreationTest() {
    // given
    val userId = "user1"
    val orderAmount = 10000L
    
    userRepository.save(User(userId))
    userPointRepository.save(UserPoint(userId, 500)) // 부족한 포인트
    
    // when & then
    assertThrows<InsufficientPointException> {
        transactionTemplate.execute {
            orderFacade.placeOrder(OrderCriteria.Create(
                userId = userId,
                totalAmount = orderAmount,
                usePoints = 1000L // 가용 포인트보다 많음
            ))
        }
    }
    
    // 주문 생성 여부 확인 (생성되지 않아야 함)
    val orders = orderRepository.findByUserId(userId)
    assertTrue(orders.isEmpty())
}
```

## 6. 테스트 데이터 준비

### 6.1 테스트 데이터 생성

테스트 데이터는 다음 방법으로 준비합니다:

1. **레포지토리를 통한 생성**: 직접 레포지토리를 사용하여 생성
```kotlin
@Autowired
private lateinit var userRepository: UserRepository

@Autowired
private lateinit var productRepository: ProductRepository

@BeforeEach
fun prepareTestData() {
    // 사용자 생성
    userRepository.save(User("user1", "user1@example.com", LocalDateTime.now(), LocalDateTime.now()))
    
    // 상품 생성
    productRepository.save(Product("product1", "테스트 상품", 1000, 100))
}
```

2. **테스트 데이터 팩토리 활용**: 반복 사용되는 데이터 생성 로직 캡슐화
```kotlin
@Autowired
private lateinit var testDataFactory: TestDataFactory

@BeforeEach
fun prepareTestData() {
    testDataFactory.createDefaultUser()
    testDataFactory.createDefaultProducts()
}
```

### 6.2 테스트 데이터 팩토리

테스트 데이터 팩토리는 다음과 같이 구현합니다:

```kotlin
@Component
class TestDataFactory(
    private val userRepository: UserRepository,
    private val productRepository: ProductRepository,
    private val userPointRepository: UserPointRepository
) {
    fun createDefaultUser(): User {
        val user = User("user1", "user1@example.com", LocalDateTime.now(), LocalDateTime.now())
        return userRepository.save(user)
    }
    
    fun createUserWithPoints(userId: String = "user1", points: Long = 10000): Pair<User, UserPoint> {
        val user = User(userId, "$userId@example.com", LocalDateTime.now(), LocalDateTime.now())
        val savedUser = userRepository.save(user)
        val userPoint = UserPoint(userId, points)
        val savedPoint = userPointRepository.save(userPoint)
        return Pair(savedUser, savedPoint)
    }
    
    fun createDefaultProducts(): List<Product> {
        return listOf(
            Product("product1", "상품 1", 1000, 100),
            Product("product2", "상품 2", 2000, 50),
            Product("product3", "상품 3", 3000, 30)
        ).map { productRepository.save(it) }
    }
}
```

## 7. 통합 시나리오 테스트

### 7.1 기본 구조

통합 시나리오 테스트는 다음 구조를 따릅니다:

```kotlin
@SpringBootTest
@Import(TestcontainersConfiguration::class)
class OrderCheckoutIntegrationTest {
    @Autowired
    private lateinit var userFacade: UserFacade
    
    @Autowired
    private lateinit var orderFacade: OrderFacade
    
    @Autowired
    private lateinit var couponUserFacade: CouponUserFacade
    
    @Autowired
    private lateinit var testDataFactory: TestDataFactory
    
    @BeforeEach
    fun setUp() {
        // 테스트 데이터 준비
        testDataFactory.createUserWithPoints()
        testDataFactory.createDefaultProducts()
    }
    
    @Test
    @DisplayName("쿠폰과 포인트를 사용하여 주문 결제 흐름 테스트")
    fun orderWithCouponAndPointsTest() {
        // given: 사전 조건 (쿠폰 발급 등)
        val couponResult = couponUserFacade.issueCoupon(CouponUserCriteria.Issue(
            userId = "user1",
            couponEventId = "event1"
        ))
        
        // when: 주문 생성 및 결제
        val orderResult = orderFacade.placeOrder(OrderCriteria.Create(
            userId = "user1",
            items = listOf(OrderItemCriteria.Create(
                productId = "product1",
                quantity = 2
            )),
            usePoints = 500,
            couponId = couponResult.couponUserId
        ))
        
        // then: 결과 검증
        assertEquals(2000, orderResult.totalAmount) // 1000 * 2
        assertEquals(1500, orderResult.discountAmount) // 쿠폰 1000 + 포인트 500
        assertEquals(500, orderResult.finalAmount) // 2000 - 1500
        
        // 포인트 차감 확인
        val userPointResult = userFacade.getUserPoint(UserPointCriteria.GetByUserId("user1"))
        assertEquals(9500, userPointResult.point) // 10000 - 500
        
        // 쿠폰 사용 확인
        val couponDetailResult = couponUserFacade.getCouponDetail(CouponUserCriteria.GetById(couponResult.couponUserId))
        assertNotNull(couponDetailResult.usedAt)
    }
}
```

### 7.2 시나리오 단계 명확히 하기

복잡한 시나리오는 단계별 주석으로 구분합니다:

```kotlin
@Test
@DisplayName("사용자 등록부터 주문 완료까지 전체 흐름 테스트")
fun endToEndUserRegistrationToOrderCompletionTest() {
    // Step 1: 사용자 등록
    val userResult = userFacade.registerUser(UserCriteria.Register(
        email = "newuser@example.com",
        password = "password123"
    ))
    
    // Step 2: 상품 조회
    val productsResult = productFacade.getAllProducts()
    val selectedProduct = productsResult.items.first()
    
    // Step 3: 장바구니 담기
    val cartResult = cartFacade.addToCart(CartCriteria.AddItem(
        userId = userResult.userId,
        productId = selectedProduct.productId,
        quantity = 1
    ))
    
    // Step 4: 주문 생성
    val orderResult = orderFacade.createOrderFromCart(OrderCriteria.CreateFromCart(
        userId = userResult.userId,
        cartId = cartResult.cartId
    ))
    
    // Step 5: 결제 진행
    val paymentResult = paymentFacade.processPayment(PaymentCriteria.Process(
        orderId = orderResult.orderId,
        paymentMethod = "CARD"
    ))
    
    // 최종 결과 검증
    assertEquals(PaymentStatus.COMPLETED, paymentResult.status)
    
    // 주문 상태 확인
    val finalOrderResult = orderFacade.getOrderById(OrderCriteria.GetById(orderResult.orderId))
    assertEquals(OrderStatus.PAID, finalOrderResult.status)
}
```

## 8. 동시성 테스트

### 8.1 동시성 테스트 기본 구조

동시성 문제를 테스트하는 기본 구조는 다음과 같습니다:

```kotlin
@Test
@DisplayName("동시에 재고를 감소시켜도 정확한 재고가 유지된다")
fun decreaseStockConcurrentlyTest() {
    // given
    val productId = "product1"
    val initialStock = 100
    val threadCount = 10
    val decreaseAmount = 2
    
    productRepository.save(Product(productId, "테스트 상품", 1000, initialStock))
    
    val executor = Executors.newFixedThreadPool(threadCount)
    val countDownLatch = CountDownLatch(threadCount)
    
    // when: 여러 스레드에서 동시에 재고 감소
    for (i in 0 until threadCount) {
        executor.submit {
            try {
                productFacade.decreaseStock(ProductCriteria.DecreaseStock(
                    productId = productId,
                    quantity = decreaseAmount
                ))
            } finally {
                countDownLatch.countDown()
            }
        }
    }
    
    // 모든 스레드 완료 대기
    countDownLatch.await(10, TimeUnit.SECONDS)
    
    // then: 예상한 재고량 검증
    val updatedProduct = productRepository.findById(productId).get()
    assertEquals(initialStock - (threadCount * decreaseAmount), updatedProduct.stock)
}
```

### 8.2 낙관적 락 테스트

낙관적 락(Optimistic Lock) 검증 테스트:

```kotlin
@Test
@DisplayName("낙관적 락이 적용된 경우 버전 충돌 시 예외가 발생한다")
fun optimisticLockingFailureTest() {
    // given
    val productId = "product1"
    productRepository.save(Product(productId, "테스트 상품", 1000, 100, version = 0))
    
    // 동시 업데이트 시뮬레이션
    val product1 = productRepository.findById(productId).get()
    val product2 = productRepository.findById(productId).get()
    
    // 첫 번째 업데이트 성공
    product1.decreaseStock(10)
    productRepository.save(product1)
    
    // 두 번째 업데이트 시도 시 버전 충돌 예상
    product2.decreaseStock(5)
    
    // then
    assertThrows<ObjectOptimisticLockingFailureException> {
        productRepository.save(product2)
    }
}
```

### 8.3 비관적 락 테스트

비관적 락(Pessimistic Lock) 검증 테스트:

```kotlin
@Test
@DisplayName("비관적 락이 적용된 데이터 업데이트 테스트")
fun pessimisticLockingTest() {
    // given
    val productId = "product1"
    productRepository.save(Product(productId, "테스트 상품", 1000, 100))
    
    val executor = Executors.newFixedThreadPool(2)
    val results = mutableListOf<Future<Boolean>>()
    
    // when: 두 트랜잭션 동시 실행
    results.add(executor.submit<Boolean> {
        try {
            return@submit transactionTemplate.execute {
                val product = productRepository.findByIdWithPessimisticLock(productId)
                Thread.sleep(500) // 첫 번째 트랜잭션이 lock을 유지
                product.decreaseStock(10)
                productRepository.save(product)
                true
            }
        } catch (e: Exception) {
            false
        }
    })
    
    Thread.sleep(100) // 첫 번째 트랜잭션이 lock을 획득할 시간
    
    results.add(executor.submit<Boolean> {
        try {
            return@submit transactionTemplate.execute {
                // 시간 초과 설정
                val product = productRepository.findByIdWithPessimisticLockTimeout(productId, 1)
                product.decreaseStock(5)
                productRepository.save(product)
                true
            }
        } catch (e: Exception) {
            false
        }
    })
    
    // then: 첫 번째는 성공, 두 번째는 타임아웃 예상
    assertTrue(results[0].get()) // 첫 번째 성공
    assertFalse(results[1].get()) // 두 번째 실패 (타임아웃)
}
```

## 9. 애플리케이션 이벤트 테스트

### 9.1 이벤트 발행 테스트

애플리케이션 이벤트 발행을 테스트:

```kotlin
@Test
@DisplayName("주문 완료 시 주문 완료 이벤트가 발행되어야 한다")
fun orderCompletionShouldPublishEvent() {
    // given
    val eventListener = mock(OrderCompletedEventListener::class.java)
    applicationContext.addApplicationListener(eventListener)
    
    // 테스트 데이터 준비
    val userId = "user1"
    val orderId = "order1"
    userRepository.save(User(userId))
    orderRepository.save(Order(orderId, userId, 1000, 0, 1000, OrderStatus.CREATED))
    
    // when
    orderFacade.completeOrder(OrderCriteria.Complete(orderId))
    
    // then
    verify(eventListener, timeout(1000)).onApplicationEvent(any(OrderCompletedEvent::class.java))
}
```

### 9.2 이벤트 핸들링 테스트

애플리케이션 이벤트 핸들링을 테스트:

```kotlin
@Test
@DisplayName("주문 완료 이벤트가 발생하면 이메일이 발송되어야 한다")
fun orderCompletedEventShouldTriggerEmailSending() {
    // given
    val emailService = mock(EmailService::class.java)
    
    // EventListener 등록
    val listener = OrderCompletedEventListener(emailService)
    applicationContext.addApplicationListener(listener)
    
    // 주문 정보 준비
    val order = Order(
        orderId = "order1",
        userId = "user1",
        totalAmount = 1000,
        discountAmount = 0,
        finalAmount = 1000,
        status = OrderStatus.COMPLETED
    )
    
    // when
    applicationEventPublisher.publishEvent(OrderCompletedEvent(this, order))
    
    // then
    verify(emailService, timeout(1000)).sendOrderConfirmationEmail(
        eq("user1"),
        eq("order1"),
        any()
    )
}
```

## 10. API 통합 테스트

애플리케이션 레이어에서 외부 API 통합을 테스트:

```kotlin
@Test
@DisplayName("외부 결제 API 연동 테스트")
fun externalPaymentApiIntegrationTest() {
    // given
    val orderId = "order1"
    val paymentAmount = 10000L
    
    // 테스트용 Order 생성
    orderRepository.save(Order(
        orderId = orderId,
        userId = "user1",
        totalAmount = paymentAmount,
        discountAmount = 0,
        finalAmount = paymentAmount,
        status = OrderStatus.CREATED
    ))
    
    // when
    val paymentResult = paymentFacade.processPayment(PaymentCriteria.Process(
        orderId = orderId,
        paymentMethod = "CARD",
        cardNumber = "1234-5678-9012-3456",
        cardExpiry = "12/25",
        cardCvc = "123"
    ))
    
    // then
    assertEquals(PaymentStatus.COMPLETED, paymentResult.status)
    
    // 주문 상태 확인
    val orderAfterPayment = orderRepository.findById(orderId).get()
    assertEquals(OrderStatus.PAID, orderAfterPayment.status)
}
```

## 11. 테스트 데이터 검증

### 11.1 직접 쿼리를 통한 검증

때로는 레포지토리 외에 직접 쿼리를 통한 검증이 필요합니다:

```kotlin
@Autowired
private lateinit var jdbcTemplate: JdbcTemplate

@Test
@DisplayName("주문 생성 시 관련 모든 테이블에 데이터가 저장되는지 확인")
fun orderCreationPersistsAllRelatedDataTest() {
    // given & when
    // 주문 생성 로직 실행
    val orderResult = orderFacade.placeOrder(/* params */)
    
    // then
    // 주문 테이블 확인
    val orderCount = jdbcTemplate.queryForObject(
        "SELECT COUNT(*) FROM orders WHERE order_id = ?",
        Int::class.java,
        orderResult.orderId
    )
    assertEquals(1, orderCount)
    
    // 주문 상품 테이블 확인
    val orderItemCount = jdbcTemplate.queryForObject(
        "SELECT COUNT(*) FROM order_items WHERE order_id = ?",
        Int::class.java,
        orderResult.orderId
    )
    assertTrue(orderItemCount > 0)
    
    // 주문 할인 테이블 확인 (쿠폰 사용 시)
    val discountCount = jdbcTemplate.queryForObject(
        "SELECT COUNT(*) FROM order_discounts WHERE order_id = ?",
        Int::class.java,
        orderResult.orderId
    )
    assertEquals(1, discountCount)
}
```

### 11.2 엔티티 그래프 검증

복잡한 엔티티 관계 검증이 필요한 경우:

```kotlin
@Test
@DisplayName("주문 조회 시 연관된 모든 엔티티가 함께 로드되는지 확인")
fun orderLoadsFetchesAllRelatedEntitiesTest() {
    // given
    // 테스트 데이터 준비 (주문, 주문상품, 할인 등)
    
    // when
    val order = orderRepository.findByIdWithAllAssociations(orderId)
    
    // then
    assertNotNull(order)
    assertFalse(order.orderItems.isEmpty())
    if (order.discounts.isNotEmpty()) {
        val discount = order.discounts.first()
        assertNotNull(discount.discountId)
    }
}
```

## 12. DB 스키마 변경 테스트

### 12.1 Flyway 마이그레이션 테스트

스키마 변경이 있는 경우 Flyway 마이그레이션 테스트:

```kotlin
@SpringBootTest
@TestPropertySource(properties = [
    "spring.flyway.enabled=true",
    "spring.jpa.hibernate.ddl-auto=validate"
])
class FlywayMigrationIntegrationTest {
    @Autowired
    private lateinit var flyway: Flyway
    
    @Test
    @DisplayName("Flyway 마이그레이션이 성공적으로 실행되어야 한다")
    fun flywayMigrationSucceeds() {
        // given & when
        val migrationInfo = flyway.info()
        val appliedMigrations = migrationInfo.applied()
        
        // then
        assertTrue(appliedMigrations.isNotEmpty())
        
        // 특정 마이그레이션 스크립트가 적용되었는지 확인
        val targetVersion = "V1.2"
        val targetMigration = appliedMigrations.find { it.version.version == targetVersion }
        assertNotNull(targetMigration)
        assertEquals("OK", targetMigration?.state.toString())
    }
}
```

### 12.2 엔티티 매핑 검증

JPA 엔티티 매핑 검증 테스트:

```kotlin
@SpringBootTest
class EntityMappingIntegrationTest {
    @Autowired
    private lateinit var entityManager: EntityManager
    
    @Test
    @DisplayName("Order 엔티티가 DB 스키마와 정상적으로 매핑되어야 한다")
    fun orderEntityMappingValidation() {
        // given
        val metadata = entityManager.metamodel
        val orderEntity = metadata.entity(Order::class.java)
        
        // when & then
        val tableName = orderEntity.getJavaType().getAnnotation(Table::class.java).name
        assertEquals("orders", tableName)
        
        // 컬럼 매핑 검증
        val attributes = orderEntity.declaredAttributes
        
        val orderIdAttribute = attributes.find { it.name == "orderId" }
        assertNotNull(orderIdAttribute)
        val orderIdColumn = Order::class.java.getDeclaredField("orderId")
            .getAnnotation(Column::class.java)
        assertEquals("order_id", orderIdColumn.name)
        
        // 중요 필드 확인
        assertTrue(attributes.any { it.name == "userId" })
        assertTrue(attributes.any { it.name == "totalAmount" })
    }
}
```

## 13. 테스트 커버리지

애플리케이션 레이어 통합 테스트는 다음 수준의 커버리지를 목표로 합니다:

1. **주요 비즈니스 시나리오**: 100% 커버리지
2. **클래스 커버리지**: 80% 이상 (주요 Facade 및 Service 클래스)
3. **메서드 커버리지**: 70% 이상 (비즈니스적으로 중요한 메서드 우선) 