# 3. 레이어드 아키텍처

## 1. 개요

본 문서는 Voyage-Shop 애플리케이션의 레이어드 아키텍처(Layered Architecture)에 대한 개요 및 각 레이어의 역할과 책임을 정의합니다.

아키텍처 개요는 다음 문서를 참조하세요:
- [1. 프로젝트 컨벤션 개요](./01.common-conventions.md)

레이어 구성에 대한 기본 설명은 [1. 프로젝트 컨벤션 개요](./01.common-conventions.md) 문서를 참조하세요. 본 문서는 아키텍처 결정의 이유를 자세히 알고 싶은 경우에만 읽으시면 됩니다.

이 문서는 [1. 프로젝트 컨벤션 개요](./01.common-conventions.md)를 읽은 후 확인하는 것을 권장합니다.

## 2. 레이어 구성

Voyage-Shop 애플리케이션은 다음과 같은 레이어로 구성됩니다:

1. **컨트롤러 레이어(Controller Layer)**: 외부 요청을 받아 처리하고 응답을 반환합니다.
2. **파사드 레이어(Facade Layer)**: 컨트롤러와 애플리케이션 레이어 사이에 위치하며, 여러 애플리케이션 서비스를 조합하여 클라이언트에게 단순화된 인터페이스를 제공합니다.
3. **애플리케이션 레이어(Application Layer)**: 여러 도메인 서비스를 조합하여 비즈니스 유스케이스를 구현하고 트랜잭션을 관리합니다.
4. **도메인 레이어(Domain Layer)**: 비즈니스 개념과 규칙을 표현하는 핵심 레이어입니다.
5. **인프라스트럭처 레이어(Infrastructure Layer)**: 외부 시스템과의 통신, 데이터베이스 접근 등 기술적 세부사항을 담당합니다.

각 레이어는 아래 레이어에만 의존하며, 상위 레이어에 의존해서는 안 됩니다.

## 3. 채택 이유

### 3.1 관심사의 분리 (Separation of Concerns)
각 레이어는 고유한 책임을 가지며, 이를 통해 코드의 가독성과 유지보수성이 향상된다. 특정 기능이나 로직을 변경할 때 관련된 레이어만 수정하면 되므로 변경 범위가 최소화된다.

### 3.2 테스트 용이성
레이어 간 명확한 경계가 있어 각 레이어를 독립적으로 테스트할 수 있다. 특히 핵심 비즈니스 로직이 있는 도메인 레이어는 외부 의존성 없이 단위 테스트가 가능하다.

### 3.3 확장성과 유연성
새로운 기능이나 요구사항이 추가될 때 기존 구조를 크게 변경하지 않고도 적용할 수 있다. 예를 들어, 데이터베이스나 외부 서비스가 변경되더라도 인프라스트럭처 레이어만 수정하면 된다.

### 3.4 클린 아키텍처 원칙 적용
의존성 방향이 내부 레이어(도메인)를 향하도록 설계하여, 핵심 비즈니스 로직이 외부 기술이나 프레임워크에 의존하지 않도록 한다. 이를 통해 시스템의 장기적인 유지보수성과 안정성을 확보할 수 있다.

### 3.5 개발 효율성
팀원들이 담당 레이어에 집중하여 개발할 수 있어 병렬적인 작업이 가능하며, 코드 구조가 일관되어 새로운 개발자가 프로젝트에 참여하기 쉽다.

## 4. 레이어별 역할과 책임

### 4.1 컨트롤러 레이어
- 외부 요청(HTTP 등)을 받아 처리
- 요청 데이터의 기본 유효성 검증
- 응답 형식 구성 및 반환
- 예외 처리 및 오류 응답 생성
- 상세 규약: [5. 컨트롤러 레이어 규약](./05.controller-layer.md)

### 4.2 파사드 레이어
- 컨트롤러와 애플리케이션 서비스 사이의 중간 계층
- 여러 애플리케이션 서비스를 조합하여 클라이언트에게 단순화된 인터페이스 제공
- 데이터 변환 및 요청 라우팅
- 복잡한 비즈니스 로직이나 트랜잭션 처리는 애플리케이션 레이어에 위임
- **선택적 도입**: 파사드 레이어는 모든 기능에 필수적으로 적용하지 않고, 복잡한 비즈니스 로직이나 여러 애플리케이션 서비스를 조합해야 하는 경우에만 선택적으로 적용합니다. 단순한 CRUD 작업이나 단일 애플리케이션 서비스만 사용하는 경우에는 컨트롤러에서 직접 애플리케이션 레이어를 호출할 수 있습니다.
- 상세 규약: [6. 파사드 레이어 규약](./06.facade-layer.md)

### 4.3 애플리케이션 레이어
- 여러 도메인 서비스를 조합하여 비즈니스 유스케이스 구현
- 트랜잭션 경계 정의 및 관리
- 분산 락 획득 및 관리를 통한 동시성 제어
- 도메인 로직 조합 및 오케스트레이션
- 상세 규약: [7. 애플리케이션 레이어 규약](./07.application-layer.md)

### 4.4 도메인 레이어
- 핵심 비즈니스 개념과 규칙 표현
- 도메인 엔티티, 값 객체, 도메인 서비스 구현
- 비즈니스 규칙 캡슐화
- 상세 규약: [8. 도메인 레이어 규약](./08.domain-layer.md)

### 4.5 인프라스트럭처 레이어
- 도메인 레이어에 정의된 인터페이스 구현
- 데이터베이스 접근, 외부 API 통신 등 기술적 세부사항 처리
- 영속성 메커니즘 제공
- 상세 규약: [9. 인프라스트럭처 레이어 규약](./09.infrastructure-layer.md)

### 4.6 서비스 레이어 간 역할 비교

다음 표는 파사드 레이어, 애플리케이션 레이어, 도메인 레이어의 서비스 간 역할 차이를 명확히 비교합니다:

| 구분 | 파사드 서비스 | 애플리케이션 서비스 | 도메인 서비스 |
|------|--------------|-------------------|--------------|
| **주요 역할** | 여러 애플리케이션 서비스 조합 및 클라이언트 인터페이스 단순화 | 여러 도메인 서비스 조합을 통한 비즈니스 유스케이스 구현 | 특정 도메인의 핵심 비즈니스 규칙과 로직 구현 |
| **책임 범위** | UI/API 요구사항에 맞게 다수의 유스케이스 조합 | 하나의 완전한 비즈니스 유스케이스 수행 | 단일 도메인 내 비즈니스 규칙 적용 |
| **트랜잭션 처리** | 트랜잭션 시작하지 않음, 애플리케이션 레이어에 위임 | 유스케이스에 필요한 트랜잭션 정의 및 관리 | 트랜잭션 처리하지 않음 |
| **락 관리** | 락 관리하지 않음, 애플리케이션 레이어에 위임 | 유스케이스의 데이터 일관성을 위한 분산 락 획득 및 관리 | 락 관리하지 않음 |
| **입력 데이터** | FacadeCriteria 객체 | Criteria 객체 | Command 또는 Query 객체 |
| **출력 데이터** | FacadeResult 객체 | Result 객체 | 도메인 엔티티, 값 객체 |
| **호출 방향** | 애플리케이션 서비스 호출 | 도메인 서비스 호출 | 도메인 엔티티 조작, 리포지토리 사용 |
| **상태 관리** | 무상태(Stateless) | 무상태(Stateless) | 무상태(Stateless) 권장 |
| **예외 처리** | 비즈니스 예외를 적절한 응답으로 변환 | 도메인 예외 포착, 트랜잭션 관련 결정 | 비즈니스 규칙 위반 시 도메인 예외 발생 |
| **예시 작업** | - 주문 생성 + 결제 처리 + 재고 확인<br>- 사용자 등록 + 초기 프로필 설정 + 환영 메일 | - 주문 생성 트랜잭션<br>- 사용자 등록 처리<br>- 상품 재고 감소 | - 상품 가격 계산<br>- 재고 유효성 검증<br>- 사용자 인증 정보 확인 |

### 서비스 호출 흐름 예시

**e-커머스 주문 시나리오:**

1. **컨트롤러 레이어**
   - 클라이언트로부터 Request 객체 수신
   - Request 객체를 FacadeCriteria로 변환
   - 파사드 서비스 호출
   - FacadeResult를 Response 객체로 변환하여 반환

2. **파사드 레이어 (OrderProcessingFacade)**
   - FacadeCriteria 수신 및 검증
   - 여러 애플리케이션 서비스 조합 호출
   - 필요시 FacadeCriteria를 여러 Criteria 객체로 변환
   - 각 애플리케이션 서비스 결과(Result)를 조합하여 FacadeResult 반환

3. **애플리케이션 레이어 (OrderApplicationService, PaymentApplicationService)**
   - Criteria 객체 수신 및 변환
   - 트랜잭션 관리
   - Criteria를 Command/Query 객체로 변환
   - 각 도메인 서비스 호출 및 결과 조합
   - 도메인 엔티티를 Result 객체로 변환하여 반환

4. **도메인 레이어 (OrderDomainService, ProductDomainService)**
   - Command/Query 객체 수신 및 검증
   - 비즈니스 규칙 적용
   - 엔티티 상태 변경
   - 리포지토리를 통한 엔티티 저장 및 조회
   - 도메인 엔티티 또는 값 객체 반환

이 계층적 구조를 통해 각 서비스는 명확한 책임 영역을 갖게 되며, 애플리케이션의 복잡성을 관리하기 쉬워집니다.

## 4.7 레이어별 데이터 전달 객체(DTO) 구조

각 레이어는 명확히 구분된 데이터 전달 객체(DTO)를 사용하며, 이를 통해 레이어 간 경계와 책임을 명확히 합니다:

### 컨트롤러 레이어
- **Request**: 클라이언트로부터 받는 요청 데이터 (예: `UserRequest.Create`)
- **Response**: 클라이언트에게 반환하는 응답 데이터 (예: `UserResponse.Single`)
- 컨트롤러는 Request를 FacadeCriteria로, FacadeResult를 Response로 변환합니다.
- 파사드 레이어가 없는 경우, Request를 직접 Criteria로, Result를 Response로 변환합니다.

### 파사드 레이어
- **FacadeCriteria**: 파사드 서비스 호출을 위한 입력 데이터 (예: `UserFacadeCriteria.Register`)
- **FacadeResult**: 파사드 서비스의 처리 결과 (예: `UserFacadeResult.RegisteredUser`)
- 파사드는 FacadeCriteria를 Criteria로, Result를 FacadeResult로 변환합니다.
- **선택적 레이어**: 이 레이어는 복잡한 조합 로직이 필요한 경우에만 선택적으로 사용되며, 단순한 작업은 컨트롤러에서 직접 애플리케이션 레이어를 호출할 수 있습니다.

### 애플리케이션 레이어
- **Criteria**: 애플리케이션 서비스 호출을 위한 입력 데이터 (예: `UserCriteria.Create`)
- **Result**: 애플리케이션 서비스의 처리 결과 (예: `UserResult.Single`)
- 애플리케이션은 Criteria를 Command/Query로, 도메인 엔티티를 Result로 변환합니다.

### 도메인 레이어
- **Command**: 상태 변경을 위한 입력 데이터 (예: `UserCommand.Create`)
- **Query**: 데이터 조회를 위한 입력 데이터 (예: `UserQuery.GetById`)
- **도메인 엔티티**: 비즈니스 개념을 표현하는 객체 (예: `User`)
- **값 객체**: 불변의 값을 표현하는 객체 (예: `Address`, `Money`)

이러한 레이어별 DTO 구조는 각 레이어의 책임을 명확히 하고, 레이어 간 결합도를 낮춰 유지보수성과 테스트 용이성을 향상시킵니다.

## 5. 다른 아키텍처와의 비교

### 5.1 헥사고날 아키텍처(Hexagonal Architecture)를 선택하지 않은 이유
헥사고날 아키텍처(포트 및 어댑터 패턴)는 도메인 중심적이고 외부 의존성과 완전히 분리된 설계를 제공하지만, 다음과 같은 이유로 본 프로젝트에서는 채택하지 않았다:

1. **복잡성**: 헥사고날 아키텍처는 포트와 어댑터를 통한 추상화 레벨이 높아 초기 설계와 구현이 더 복잡하다. 현재 프로젝트 규모와 팀 구성에서는 이러한 복잡성이 실질적인 이점으로 이어지지 않을 수 있다.

2. **오버엔지니어링 위험**: 현재 프로젝트의 복잡성과 요구사항을 고려할 때, 헥사고날 아키텍처는 오버엔지니어링이 될 가능성이 있었다.

3. **학습 곡선**: 레이어드 아키텍처는 팀원들에게 더 익숙하고 직관적이며, 새로운 개발자가 프로젝트에 참여하기 위한 학습 곡선이 더 완만하다.

4. **점진적 전환 가능성**: 레이어드 아키텍처에서 필요에 따라 헥사고날 패턴의 일부 요소를 도입할 수 있는 유연성을 유지하면서도, 초기 개발 속도와 생산성을 높일 수 있다.

### 5.2 마이크로서비스 아키텍처를 선택하지 않은 이유
마이크로서비스 아키텍처는 다음과 같은 이유로 현재 단계에서 적합하지 않다고 판단했다:

1. **프로젝트 규모**: 현재 프로젝트 규모에서는 모놀리식 아키텍처가 개발 복잡성과 운영 오버헤드를 줄이는 데 더 효과적이다.

2. **운영 복잡성**: 마이크로서비스는 배포, 모니터링, 장애 처리 등에서 추가적인 복잡성을 도입한다.

### 5.3 이벤트 기반 아키텍처를 선택하지 않은 이유
이벤트 기반 아키텍처는 다음과 같은 이유로 현재 단계에서 적합하지 않다고 판단했다:

1. **요구사항 복잡성**: 현재 비즈니스 요구사항이 이벤트 기반 통신을 필수적으로 요구하지 않는다.

2. **디버깅 어려움**: 이벤트 기반 시스템은 비동기 처리로 인해 디버깅과 테스트가 더 어려울 수 있다.

3. **일관성 보장**: 현재 프로젝트에서는 트랜잭션의 일관성이 중요하며, 레이어드 아키텍처에서 이를 더 직관적으로 관리할 수 있다.

## 6. 결론
레이어드 아키텍처는 프로젝트의 복잡성을 관리하고, 코드의 재사용성과 유지보수성을 높이는 데 효과적인 방법이다. 다른 아키텍처 패턴들과 비교했을 때, 현재 프로젝트의 규모, 팀 구성, 비즈니스 요구사항에 가장 적합한 선택이라고 판단했다. 필요에 따라 미래에 다른 아키텍처 패턴의 요소들을 점진적으로 도입할 수 있는 유연성도 유지하고 있다. 파사드 레이어의 도입은 각 레이어의 책임을 더 명확히 분리하고, 특히 여러 애플리케이션 서비스를 조합해야 하는 복잡한 시나리오에서 코드의 가독성과 유지보수성을 향상시키는 데 도움이 된다. 