# 레이어드 아키텍처 채택 이유

## 개요
본 프로젝트에서는 다음과 같은 레이어드 아키텍처를 채택하였다:

* **Controller**: 단순히 Req, Res 및 API-Docs 정의
* **Application**: 도메인 서비스 조합, 트랜잭션 관리
* **Domain**: 각 도메인 별 정책 및 기능 정의
* **Infrastructure**: 레포지터리 등 외부 인프라 연동

## 채택 이유

### 1. 관심사의 분리 (Separation of Concerns)
각 레이어는 고유한 책임을 가지며, 이를 통해 코드의 가독성과 유지보수성이 향상된다. 특정 기능이나 로직을 변경할 때 관련된 레이어만 수정하면 되므로 변경 범위가 최소화된다.

### 2. 테스트 용이성
레이어 간 명확한 경계가 있어 각 레이어를 독립적으로 테스트할 수 있다. 특히 핵심 비즈니스 로직이 있는 도메인 레이어는 외부 의존성 없이 단위 테스트가 가능하다.

### 3. 확장성과 유연성
새로운 기능이나 요구사항이 추가될 때 기존 구조를 크게 변경하지 않고도 적용할 수 있다. 예를 들어, 데이터베이스나 외부 서비스가 변경되더라도 인프라스트럭처 레이어만 수정하면 된다.

### 4. 클린 아키텍처 원칙 적용
의존성 방향이 내부 레이어(도메인)를 향하도록 설계하여, 핵심 비즈니스 로직이 외부 기술이나 프레임워크에 의존하지 않도록 한다. 이를 통해 시스템의 장기적인 유지보수성과 안정성을 확보할 수 있다.

### 5. 개발 효율성
팀원들이 담당 레이어에 집중하여 개발할 수 있어 병렬적인 작업이 가능하며, 코드 구조가 일관되어 새로운 개발자가 프로젝트에 참여하기 쉽다.

## 다른 아키텍처와의 비교

### 헥사고날 아키텍처(Hexagonal Architecture)를 선택하지 않은 이유
헥사고날 아키텍처(포트 및 어댑터 패턴)는 도메인 중심적이고 외부 의존성과 완전히 분리된 설계를 제공하지만, 다음과 같은 이유로 본 프로젝트에서는 채택하지 않았다:

1. **복잡성**: 헥사고날 아키텍처는 포트와 어댑터를 통한 추상화 레벨이 높아 초기 설계와 구현이 더 복잡하다. 현재 프로젝트 규모와 팀 구성에서는 이러한 복잡성이 실질적인 이점으로 이어지지 않을 수 있다.

2. **오버엔지니어링 위험**: 현재 프로젝트의 복잡성과 요구사항을 고려할 때, 헥사고날 아키텍처는 오버엔지니어링이 될 가능성이 있었다.

3. **학습 곡선**: 레이어드 아키텍처는 팀원들에게 더 익숙하고 직관적이며, 새로운 개발자가 프로젝트에 참여하기 위한 학습 곡선이 더 완만하다.

4. **점진적 전환 가능성**: 레이어드 아키텍처에서 필요에 따라 헥사고날 패턴의 일부 요소를 도입할 수 있는 유연성을 유지하면서도, 초기 개발 속도와 생산성을 높일 수 있다.

### 마이크로서비스 아키텍처를 선택하지 않은 이유
마이크로서비스 아키텍처는 다음과 같은 이유로 현재 단계에서 적합하지 않다고 판단했다:

1. **프로젝트 규모**: 현재 프로젝트 규모에서는 모놀리식 아키텍처가 개발 복잡성과 운영 오버헤드를 줄이는 데 더 효과적이다.

2. **운영 복잡성**: 마이크로서비스는 배포, 모니터링, 장애 처리 등에서 추가적인 복잡성을 도입한다.

### 이벤트 기반 아키텍처를 선택하지 않은 이유
이벤트 기반 아키텍처는 다음과 같은 이유로 현재 단계에서 적합하지 않다고 판단했다:

1. **요구사항 복잡성**: 현재 비즈니스 요구사항이 이벤트 기반 통신을 필수적으로 요구하지 않는다.

2. **디버깅 어려움**: 이벤트 기반 시스템은 비동기 처리로 인해 디버깅과 테스트가 더 어려울 수 있다.

3. **일관성 보장**: 현재 프로젝트에서는 트랜잭션의 일관성이 중요하며, 레이어드 아키텍처에서 이를 더 직관적으로 관리할 수 있다.

## 결론
레이어드 아키텍처는 프로젝트의 복잡성을 관리하고, 코드의 재사용성과 유지보수성을 높이는 데 효과적인 방법이다. 다른 아키텍처 패턴들과 비교했을 때, 현재 프로젝트의 규모, 팀 구성, 비즈니스 요구사항에 가장 적합한 선택이라고 판단했다. 필요에 따라 미래에 다른 아키텍처 패턴의 요소들을 점진적으로 도입할 수 있는 유연성도 유지하고 있다. 