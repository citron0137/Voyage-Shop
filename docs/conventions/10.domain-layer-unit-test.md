# 10. 도메인 레이어 유닛 테스트 컨벤션

## 1. 개요

본 문서는 Voyage-Shop 애플리케이션의 도메인 레이어 유닛 테스트 작성 시 일관성을 유지하고, 테스트 품질을 향상시키기 위한 규약을 정의합니다. 모든 개발자는 본 규약을 숙지하고 준수하는 것을 원칙으로 합니다.

도메인 레이어 테스트의 목적은 비즈니스 규칙과 로직이 올바르게 동작하는지 검증하는 것입니다. 이 테스트는 외부 의존성 없이 도메인 자체의 동작을 검증합니다.

## 2. 테스트 디렉토리 구조

```
src/test/kotlin/kr/hhplus/be/server/
└── domain/                     # 도메인 레이어 테스트
    ├── user/                   # 사용자 도메인 테스트
    │   ├── UserTest.kt         # 사용자 엔티티 테스트
    │   └── UserServiceTest.kt  # 사용자 서비스 테스트
    ├── order/                  # 주문 도메인 테스트
    │   ├── OrderTest.kt        # 주문 엔티티 테스트
    │   └── OrderServiceTest.kt # 주문 서비스 테스트
    └── ...                     # 기타 도메인 테스트
```

## 3. 테스트 네이밍 규칙

### 3.1 클래스 네이밍

- 도메인 엔티티 테스트: `{엔티티명}Test` (예: `UserTest`)
- 도메인 서비스 테스트: `{서비스명}Test` (예: `OrderServiceTest`)
- 도메인 정책 테스트: `{정책명}Test` (예: `DiscountPolicyTest`)

### 3.2 메서드 네이밍

테스트 메소드명은 모두 영어로 작성하고, `@DisplayName`으로 한글 제목을 지정합니다.

```kotlin
@Test
@DisplayName("주문 생성 시 상품 가격의 합계가 올바르게 계산되어야 한다")
fun calculateTotalPriceCorrectlyWhenCreatingOrder() {
    // 테스트 코드
}
```

### 3.3 메서드 네이밍 패턴

메서드 이름은 다음 패턴을 따릅니다:

1. `{테스트대상행위}_{조건}_{기대결과}` 형식 권장
   - 예: `calculateTotalPrice_withMultipleItems_returnsCorrectSum`

2. 접두사를 사용한 BDD 스타일도 가능
   - 예: `shouldCalculateTotalPriceCorrectly` 또는 `givenMultipleItems_whenCalculating_thenTotalIsCorrect`

## 4. 테스트 구조

### 4.1 기본 구조

모든 테스트는 Given-When-Then 패턴을 따라 구성합니다:

```kotlin
@Test
@DisplayName("주문 생성 시 상품 가격의 합계가 올바르게 계산되어야 한다")
fun calculateTotalPriceCorrectlyWhenCreatingOrder() {
    // given: 테스트 사전 조건 설정
    val items = listOf(
        OrderItem("item1", 1000, 2),
        OrderItem("item2", 2000, 1)
    )
    
    // when: 테스트 대상 메서드 실행
    val order = Order.create("user1", items)
    
    // then: 결과 검증
    assertEquals(4000, order.totalAmount)
}
```

### 4.2 주석 처리

- 각 단계를 명확히 구분하기 위해 `// given:`, `// when:`, `// then:` 주석을 사용합니다.
- 복잡한 테스트의 경우 각 단계에 추가 설명 주석을 달아 테스트 의도를 명확히 합니다.

## 5. 테스트 독립성

### 5.1 독립성 원칙

모든 테스트는 독립적으로 실행 가능해야 합니다:

1. **상태 공유 없음**: 테스트 간 상태를 공유하지 않도록 설계
2. **테스트 순서 의존성 없음**: 테스트 실행 순서에 의존하지 않도록 구현
3. **외부 의존성 격리**: 외부 시스템에 의존하지 않고 테스트 가능하도록 구현

### 5.2 테스트 데이터 관리

테스트 데이터는 다음 원칙에 따라 관리합니다:

1. **테스트 클래스 내 생성**: 가능한 테스트 메서드 내에서 모든 테스트 데이터 생성
2. **공통 데이터 팩토리**: 반복적으로 사용되는 테스트 데이터는 팩토리 메서드로 제공
3. **불변 테스트 데이터**: 테스트 데이터는 불변으로 설계하여 부작용 방지

```kotlin
// 공통 테스트 데이터 팩토리 메서드 예시
private fun createSampleUser(userId: String = "user1"): User {
    return User(userId, LocalDateTime.now(), LocalDateTime.now())
}
```

## 6. 테스트 가독성

### 6.1 가독성 향상 원칙

1. **명확한 단언문**: 의도가 명확한 단언문 사용
2. **의미 있는 변수명**: 변수명을 통해 테스트 의도 전달
3. **테스트 설명 주석**: 복잡한 테스트의 경우 설명 주석 추가
4. **과도한 검증 지양**: 테스트 의도와 관련 없는 검증은 지양

### 6.2 헬퍼 메서드 활용

복잡한 설정이나 검증 로직은 헬퍼 메서드로 분리하여 가독성을 높입니다:

```kotlin
@Test
@DisplayName("주문 취소 시 모든 주문 상품이 취소됨")
fun cancelOrder_shouldCancelAllOrderItems() {
    // given
    val order = createOrderWithMultipleItems()
    
    // when
    order.cancel()
    
    // then
    assertAllItemsCanceled(order)
}

private fun createOrderWithMultipleItems(): Order {
    // 여러 상품이 있는 주문 생성 로직
}

private fun assertAllItemsCanceled(order: Order) {
    order.items.forEach {
        assertTrue(it.isCanceled)
    }
}
```

## 7. 예외 테스트

### 7.1 예외 테스트 패턴

예외 테스트는 다음 패턴 중 하나를 사용합니다:

1. **assertThrows 사용**:
   ```kotlin
   @Test
   @DisplayName("재고가 부족하면 예외가 발생해야 한다")
   fun createOrder_withInsufficientStock_shouldThrowException() {
       // given
       val insufficientStockItem = OrderItem("item1", 1000, 100)
       
       // when & then
       val exception = assertThrows<InsufficientStockException> {
           Order.create("user1", listOf(insufficientStockItem))
       }
       
       // 예외 메시지 검증 (필요한 경우)
       assertEquals("재고가 부족합니다", exception.message)
   }
   ```

2. **try-catch 패턴**:
   ```kotlin
   @Test
   @DisplayName("재고가 부족하면 예외가 발생해야 한다")
   fun createOrder_withInsufficientStock_shouldThrowException() {
       // given
       val insufficientStockItem = OrderItem("item1", 1000, 100)
       
       try {
           // when
           Order.create("user1", listOf(insufficientStockItem))
           
           // then
           fail("예외가 발생해야 합니다")
       } catch (e: InsufficientStockException) {
           // 예외 발생이 기대하는 동작
           assertEquals("재고가 부족합니다", e.message)
       }
   }
   ```

### 7.2 예외 테스트 네이밍

예외 테스트 메서드 이름은 예외 상황을 명확히 표현해야 합니다:

- `{메서드명}_with{조건}_shouldThrow{예외타입}` 패턴 권장
- 예: `createOrder_withNegativePrice_shouldThrowIllegalArgumentException`

## 8. 테스트 코드 품질

### 8.1 중복 제거

반복적인 테스트 코드는 다음 방법으로 중복을 제거합니다:

1. **팩토리 메서드**: 공통 객체 생성을 위한 팩토리 메서드 활용
2. **헬퍼 메서드**: 공통 검증 로직을 헬퍼 메서드로 분리
3. **파라미터화 테스트**: 유사한 테스트 케이스는 파라미터화 테스트로 통합

### 8.2 파라미터화 테스트 활용

다양한 입력에 대해 동일한 검증이 필요한 경우 JUnit5의 파라미터화 테스트를 활용합니다:

```kotlin
@ParameterizedTest
@DisplayName("유효하지 않은 주문 상태 전환은 예외가 발생해야 한다")
@MethodSource("invalidStateTransitions")
fun invalidStateTransition_shouldThrowException(testCase: StateTransitionTestCase) {
    // given
    val order = Order.create("user1", emptyList())
    // 초기 상태로 설정
    testCase.setupInitialState(order)
    
    // when & then
    assertThrows<IllegalStateException> {
        testCase.executeStateTransition(order)
    }
}

private data class StateTransitionTestCase(
    val description: String,
    val setupInitialState: (Order) -> Unit,
    val executeStateTransition: (Order) -> Unit
)

private fun invalidStateTransitions() = Stream.of(
    StateTransitionTestCase(
        "취소된 주문을 배송 중으로 변경 불가",
        { it.cancel() },
        { it.shipping() }
    ),
    StateTransitionTestCase(
        "배송 완료된 주문을 배송 중으로 변경 불가",
        { it.shipping(); it.complete() },
        { it.shipping() }
    )
    // 추가 케이스...
)
```

## 9. Mock 사용 원칙

### 9.1 Mock 사용 범위

도메인 레이어 테스트에서 Mock 사용은 최소화하는 것을 원칙으로 합니다:

1. **도메인 엔티티**: Mock 사용하지 않고 실제 객체 사용
2. **도메인 서비스**: 의존하는 레포지토리는 Mock으로 대체 가능
3. **외부 인프라 의존성**: 항상 Mock으로 대체

### 9.2 Mock 라이브러리

Mock 구현 시 Mockk 라이브러리를 사용합니다:

```kotlin
@Test
@DisplayName("주문 완료 시 재고가 차감되어야 한다")
fun completeOrder_shouldReduceStock() {
    // given
    val productRepository = mockk<ProductRepository>()
    val orderService = OrderService(productRepository)
    
    val productId = "product1"
    val orderedQuantity = 2
    val product = Product(productId, 10) // 초기 재고 10
    
    // Mock 동작 설정
    every { productRepository.findById(productId) } returns product
    every { productRepository.save(any()) } answers { firstArg() }
    
    // when
    orderService.completeOrder(Order("order1", productId, orderedQuantity))
    
    // then
    verify {
        productRepository.save(match { 
            it.id == productId && it.stock == 8 
        })
    }
}
```

## 10. 테스트 커버리지

### 10.1 커버리지 목표

도메인 레이어는 높은 테스트 커버리지를 유지해야 합니다:

1. **클래스 커버리지**: 100% (모든 도메인 클래스는 테스트 대상)
2. **메서드 커버리지**: 95% 이상 (핵심 비즈니스 로직 메서드는 100%)
3. **라인 커버리지**: 90% 이상

### 10.2 테스트 우선순위

테스트 우선순위는 다음과 같습니다:

1. **핵심 비즈니스 규칙**: 가장 높은 우선순위로 테스트
2. **복잡한 로직**: 다양한 조건과 분기가 있는 복잡한 로직 집중 테스트
3. **경계 조건**: 경계값 및 예외 케이스 테스트

## 11. 실제 예시 코드

### 11.1 도메인 엔티티 테스트 예시

```kotlin
class OrderTest {
    @Test
    @DisplayName("주문 생성 시 총 금액이 올바르게 계산되어야 한다")
    fun calculateTotalAmount_withMultipleItems_returnsCorrectSum() {
        // given
        val items = listOf(
            OrderItem("item1", 1000, 2),  // 2000원
            OrderItem("item2", 1500, 3)   // 4500원
        )
        
        // when
        val order = Order.create("user1", items)
        
        // then
        assertEquals(6500, order.totalAmount)
    }
    
    @Test
    @DisplayName("할인이 적용된 주문은 할인 금액이 차감되어야 한다")
    fun calculateFinalAmount_withDiscount_returnsDiscountedAmount() {
        // given
        val items = listOf(OrderItem("item1", 1000, 2))  // 2000원
        val discountAmount = 500L
        
        // when
        val order = Order.create("user1", items)
        order.applyDiscount(discountAmount)
        
        // then
        assertEquals(2000, order.totalAmount)
        assertEquals(500, order.discountAmount)
        assertEquals(1500, order.finalAmount)
    }
    
    @Test
    @DisplayName("주문 취소 시 상태가 CANCELED로 변경되어야 한다")
    fun cancel_changesStatusToCanceled() {
        // given
        val order = Order.create("user1", listOf(OrderItem("item1", 1000, 1)))
        
        // when
        order.cancel()
        
        // then
        assertEquals(OrderStatus.CANCELED, order.status)
    }
    
    @Test
    @DisplayName("이미 배송 완료된 주문은 취소할 수 없다")
    fun cancel_whenOrderAlreadyDelivered_throwsException() {
        // given
        val order = Order.create("user1", listOf(OrderItem("item1", 1000, 1)))
        order.shipping()
        order.complete()
        
        // when & then
        assertThrows<IllegalStateException> {
            order.cancel()
        }
    }
}
```

### 11.2 도메인 서비스 테스트 예시

```kotlin
class OrderServiceTest {
    private lateinit var orderRepository: OrderRepository
    private lateinit var productRepository: ProductRepository
    private lateinit var orderService: OrderService
    
    @BeforeEach
    fun setUp() {
        orderRepository = mockk()
        productRepository = mockk()
        orderService = OrderService(orderRepository, productRepository)
    }
    
    @Test
    @DisplayName("주문 생성 후 저장 시 주문 ID가 반환되어야 한다")
    fun createOrder_savedSuccessfully_returnsOrderId() {
        // given
        val userId = "user1"
        val productId = "product1"
        val quantity = 2
        
        val product = Product(productId, "테스트 상품", 1000, 10)
        val orderCommand = OrderCommand.Create(
            userId = userId,
            items = listOf(OrderItemCommand.Create(productId, quantity))
        )
        
        every { productRepository.findById(productId) } returns product
        every { orderRepository.save(any()) } answers { 
            val order = firstArg<Order>()
            order.apply { orderId = "generated-id" }
        }
        
        // when
        val result = orderService.createOrder(orderCommand)
        
        // then
        assertNotNull(result)
        assertEquals("generated-id", result.orderId)
        
        // verify
        verify { orderRepository.save(any()) }
    }
    
    @Test
    @DisplayName("재고가 부족한 상품으로 주문 생성 시 예외가 발생해야 한다")
    fun createOrder_withInsufficientStock_throwsException() {
        // given
        val userId = "user1"
        val productId = "product1"
        val quantity = 11  // 재고(10)보다 많은 수량
        
        val product = Product(productId, "테스트 상품", 1000, 10)
        val orderCommand = OrderCommand.Create(
            userId = userId,
            items = listOf(OrderItemCommand.Create(productId, quantity))
        )
        
        every { productRepository.findById(productId) } returns product
        
        // when & then
        assertThrows<InsufficientStockException> {
            orderService.createOrder(orderCommand)
        }
        
        // verify
        verify(exactly = 0) { orderRepository.save(any()) }
    }
}
``` 