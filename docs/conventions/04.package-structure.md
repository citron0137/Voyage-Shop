# 4. 패키지 구조

## 1. 개요

본 문서는 Voyage-Shop 애플리케이션의 패키지 구조에 대한 지침을 제공합니다. 이 지침은 코드의 일관성을 유지하고 가독성과 유지보수성을 향상시키기 위한 것입니다.

패키지 구조에 대한 자세한 내용은 다음 문서를 참조하세요:
- [1. 프로젝트 컨벤션 개요](./01.common-conventions.md)

이 문서는 [1. 프로젝트 컨벤션 개요](./01.common-conventions.md)와 [3. 레이어드 아키텍처 상세](./03.layered-architecture.md)를 읽은 후 확인하는 것을 권장합니다.

## 2. 레이어 우선 패키지 구조 예시

```
src/
  ├── controller/
  │   ├── product/
  │   ├── order/
  │   └── user/
  ├── facade/
  │   ├── product/
  │   ├── order/
  │   └── user/
  ├── application/
  │   ├── product/
  │   ├── order/
  │   └── user/
  ├── domain/
  │   ├── product/
  │   ├── order/
  │   └── user/
  └── infrastructure/
      ├── product/
      ├── order/
      └── user/
```

## 3. 선택 이유

### 3.1 관심사의 명확한 분리
레이어를 최상위 구분 기준으로 삼음으로써 코드베이스 내에서 각 기능적 계층이 명확하게 구분된다. 이는 개발자가 특정 레이어의 책임과 역할을 명확히 이해하는 데 도움이 된다.

### 3.2 코드 탐색 용이성
레이어 우선 구조는 특정 계층에서 어떤 기능이 구현되어 있는지 빠르게 탐색할 수 있게 한다. 예를 들어, 모든 컨트롤러가 한 패키지에 모여 있어 API 엔드포인트 전체를 파악하기 쉽다.

### 3.3 레이어 간 경계 강화
레이어별로 패키지를 구분함으로써 레이어 간 의존성 방향을 강제할 수 있다. 이는 잘못된 의존성 방향(예: 도메인 레이어가 인프라스트럭처 레이어에 의존)을 쉽게 발견할 수 있게 한다.

특히 다음과 같은 이점이 있다:

- **Import문을 통한 직관적인 의존성 확인**: 코드의 import문을 보는 것만으로도 역참조가 발생하는지 직관적으로 확인할 수 있다. 예를 들어, domain 패키지에서 infrastructure 패키지로의 import가 발생한다면 이는 명확한 아키텍처 위반으로 쉽게 발견된다.

```java
// 올바른 의존성 방향
package com.voyage.infrastructure.product;
import com.voyage.domain.product.Product;

// 잘못된 의존성 방향 (쉽게 발견 가능)
package com.voyage.domain.product;
import com.voyage.infrastructure.product.ProductRepository; // 이런 import가 있다면 쉽게 발견 가능
```

- **IDE 도구를 활용한 의존성 분석**: IntelliJ IDEA의 Dependency Graph와 같은 도구를 활용하여 패키지 간 의존성을 시각적으로 분석할 수 있다. 레이어 기반 패키지 구조에서는 의존성 방향이 명확히 드러나므로, 이러한 도구를 통해 아키텍처 위반을 쉽게 감지하고 수정할 수 있다.

### 3.4 레이어별 특성 반영
각 레이어마다 도메인의 표현 방식이 다를 수 있다는 점을 인정하고, 이를 패키지 구조에 반영했다. 예를 들어:

- **컨트롤러 레이어**: DTO 중심
- **파사드 레이어**: 여러 애플리케이션 서비스 조합 중심
- **애플리케이션 레이어**: 유스케이스 중심
- **도메인 레이어**: 엔티티와 도메인 정책 중심
- **인프라스트럭처 레이어**: 외부 시스템 연동 중심

### 3.5 동시 개발 효율성
다수의 개발자가 동시에 작업할 때, 레이어별로 담당을 나누어 작업할 수 있어 병렬 개발이 용이하다. 이는 코드 충돌을 최소화하고 개발 속도를 향상시킨다.

## 4. 레이어별 패키지 구조 세부 설명

### 4.1 컨트롤러 레이어 (controller)
```
controller/
  └── {도메인}/
      ├── {도메인}Controller.kt
      ├── {도메인}ControllerApi.kt
      ├── {도메인}Request.kt
      └── {도메인}Response.kt
```

### 4.2 파사드 레이어 (facade)
```
facade/
  └── {도메인}/
      ├── {도메인}Facade.kt
      ├── {도메인}FacadeCriteria.kt
      └── {도메인}FacadeResult.kt
```

### 4.3 애플리케이션 레이어 (application)
```
application/
  └── {도메인}/
      ├── {도메인}Application.kt
      ├── {도메인}Criteria.kt
      └── {도메인}Result.kt
```

### 4.4 도메인 레이어 (domain)
```
domain/
  └── {도메인}/
      ├── {도메인}.kt
      ├── {도메인}Repository.kt
      ├── {도메인}Service.kt
      ├── {도메인}Command.kt
      └── {도메인}Exception.kt
```

### 4.5 인프라스트럭처 레이어 (infrastructure)
```
infrastructure/
  └── {도메인}/
      ├── {도메인}RepositoryImpl.kt
      ├── {도메인}JpaRepository.kt
      └── {도메인}JpaEntity.kt
```

## 5. 의존성 규칙

레이어 간 의존성 방향은 다음 원칙을 따릅니다:

1. 상위 레이어는 하위 레이어에만 의존할 수 있습니다.
   - 컨트롤러는 파사드와 애플리케이션에 의존 가능
   - 파사드는 애플리케이션에 의존 가능
   - 애플리케이션은 도메인에 의존 가능
   - 도메인은 어떤 다른 레이어에도 의존하지 않음
   - 인프라스트럭처는 도메인에만 의존 (구현 관계)

2. 역방향 의존성은 엄격히 금지됩니다:
   - 도메인이 인프라스트럭처, 애플리케이션, 파사드, 컨트롤러에 의존 불가
   - 애플리케이션이 파사드나 컨트롤러에 의존 불가
   - 파사드가 컨트롤러에 의존 불가

## 6. 다른 패키지 구조와의 비교

### 6.1 도메인 우선 구조를 선택하지 않은 이유
도메인을 먼저 구분하고 그 안에 레이어를 배치하는 방식은 다음과 같은 이유로 채택하지 않았다:

```
src/
  ├── product/
  │   ├── controller/
  │   ├── facade/
  │   ├── application/
  │   ├── domain/
  │   └── infrastructure/
  ├── order/
  │   ├── controller/
  │   ├── facade/
  │   ├── application/
  │   ├── domain/
  │   └── infrastructure/
  └── user/
      ├── controller/
      ├── facade/
      ├── application/
      ├── domain/
      └── infrastructure/
```

1. **기술적 일관성 저하**: 도메인별로 레이어 구현이 다르게 발전할 가능성이 높아 기술적 일관성을 유지하기 어렵다.

2. **교차 도메인 기능 구현의 어려움**: 여러 도메인에 걸친 기능을 구현할 때 코드가 분산되어 유지보수가 어려워질 수 있다.

3. **레이어 간 경계 약화**: 레이어의 경계가 도메인별로 흐려질 수 있어 아키텍처 원칙을 유지하기 어려울 수 있다.

4. **비즈니스 변경에 대한 유연성**: 비즈니스 요구사항이 빠르게 변경될 때 도메인 우선 구조는 변경 범위가 커질 수 있다. 새로운 도메인이 추가되거나 기존 도메인 간 경계가 변경되는 경우, 레이어 우선 구조에서는 관련 레이어 내의 패키지만 수정하면 되지만, 도메인 우선 구조에서는 전체 패키지 구조를 재구성해야 할 수 있다. 특히 초기 단계의 프로젝트에서는 도메인 경계가 자주 변경될 수 있으므로, 레이어 우선 구조가 이러한 변화에 더 효과적으로 대응할 수 있다.

### 6.2 기능 중심 구조를 선택하지 않은 이유
특정 기능이나 유스케이스를 중심으로 패키지를 구성하는 방식은 다음 이유로 채택하지 않았다:

1. **코드 재사용성 저하**: 기능별로 패키지가 분리되면 유사한 코드가 중복될 가능성이 높다.

2. **도메인 모델의 일관성 유지 어려움**: 도메인 모델이 기능별로 분산되어 일관성 있는 도메인 모델을 유지하기 어렵다.

## 7. 파사드 레이어 사용 가이드라인

파사드 레이어는 레이어드 아키텍처의 추가적인 계층으로, 여러 애플리케이션 서비스를 조합해야 하는 복잡한 상황에서 선택적으로 사용합니다. 가이드라인은 다음과 같습니다:

1. **선택적 사용**: 모든 도메인이나 기능에 파사드 레이어를 적용할 필요는 없습니다. 다음 상황에서 주로 사용합니다:
   - 여러 애플리케이션 서비스를 조합해야 하는 경우
   - 공통된 요청 처리 패턴이 반복되는 경우
   - 컨트롤러와 애플리케이션 서비스 사이의 복잡한 변환 작업이 필요한 경우

2. **패키지 배치**: 파사드 레이어 클래스는 항상 `facade/{도메인}` 패키지에 위치시킵니다.

3. **명명 규칙**: 파사드 클래스는 `{도메인}Facade` 형식으로 명명합니다. (예: `UserFacade`, `OrderFacade`)

4. **의존성 방향**: 파사드는 컨트롤러보다 아래, 애플리케이션 레이어보다 위에 위치하며, 아래 방향으로만 의존성을 가집니다.

## 8. 결론
레이어 우선의 패키지 구조는 레이어드 아키텍처의 원칙을 강화하고, 코드의 탐색성과 유지보수성을 높이는 동시에 팀의 효율적인 협업을 지원합니다. 이 구조는 현재 프로젝트의 규모와 팀 구성에 가장 적합하며, 향후 프로젝트 성장에 따라 필요시 패키지 구조의 진화를 고려할 수 있습니다. 파사드 레이어의 추가는 복잡한 기능 구현 시 코드의 가독성과 유지보수성을 향상시키는 데 기여합니다. 