# 13. AOP 기반 분산 락 시스템 사용 가이드라인

## 1. 개요

본 문서는 Voyage-Shop 애플리케이션에서 AOP(Aspect-Oriented Programming)를 활용한 분산 락 관리에 관한 규약을 정의합니다. 이 문서는 [12. 분산 락 키 관리 가이드라인](./12.lock-key-guidelines.md) 문서를 보완합니다.

AOP 기반 분산 락 시스템은 다음과 같은 이점을 제공합니다:
- 비즈니스 로직과 락 관리 코드의 분리
- 반복적인 락 획득/해제 코드 제거
- 선언적 락 관리를 통한 가독성 향상
- 락 관리 실수 감소

## 2. 분산 락 애노테이션

### 2.1 `@DistributedLock` 애노테이션

단일 리소스에 대한 락을 획득하기 위한 애노테이션입니다.

```kotlin
@DistributedLock(
    domain = LockKeyConstants.ORDER_PREFIX,
    resourceType = LockKeyConstants.RESOURCE_ID,
    resourceIdExpression = "orderId",
    timeout = LockKeyConstants.DEFAULT_TIMEOUT
)
fun updateOrderStatus(orderId: String, status: OrderStatus): OrderResult.Single {
    // 비즈니스 로직
}
```

#### 속성 설명

- `domain`: 도메인 프리픽스 (LockKeyConstants 상수 사용)
- `resourceType`: 리소스 타입 (LockKeyConstants 상수 사용)
- `resourceIdExpression`: 리소스 ID를 추출할 표현식
- `timeout`: 락 획득 대기 시간 (기본값: LockKeyConstants.DEFAULT_TIMEOUT)
- `timeUnit`: 시간 단위 (기본값: TimeUnit.SECONDS)

### 2.2 `@CompositeLock` 애노테이션

여러 리소스에 대한 락을 동시에 획득하기 위한 애노테이션입니다.

```kotlin
@CompositeLock(
    locks = [
        DistributedLock(
            domain = LockKeyConstants.ORDER_PREFIX,
            resourceType = LockKeyConstants.RESOURCE_USER,
            resourceIdExpression = "criteria.userId",
            timeout = LockKeyConstants.EXTENDED_TIMEOUT
        ),
        DistributedLock(
            domain = LockKeyConstants.COUPON_USER_PREFIX,
            resourceType = LockKeyConstants.RESOURCE_ID,
            resourceIdExpression = "criteria.couponUserId"
        )
    ],
    ordered = true
)
fun createOrder(criteria: OrderCriteria.Create): OrderResult.Single {
    // 비즈니스 로직
}
```

#### 속성 설명

- `locks`: 획득할 락들의 배열
- `ordered`: 락 획득 시 정렬 여부 (데드락 방지를 위해 기본값 true)

## 3. 리소스 ID 표현식

리소스 ID 표현식은 메서드 파라미터에서 실제 값을 추출하는 데 사용됩니다.

### 3.1 기본 파라미터 참조

```kotlin
@DistributedLock(
    domain = LockKeyConstants.ORDER_PREFIX,
    resourceType = LockKeyConstants.RESOURCE_ID,
    resourceIdExpression = "orderId"
)
fun getOrder(orderId: String): OrderResult.Single {
    // 비즈니스 로직
}
```

### 3.2 중첩 필드 참조

```kotlin
@DistributedLock(
    domain = LockKeyConstants.ORDER_PREFIX,
    resourceType = LockKeyConstants.RESOURCE_USER,
    resourceIdExpression = "criteria.userId"
)
fun getOrdersByUserId(criteria: OrderCriteria.GetByUserId): OrderResult.List {
    // 비즈니스 로직
}
```

## 4. AOP 기반 락과 명시적 락의 혼합 사용

복잡한 시나리오에서는 AOP 기반 락과 명시적 락 코드를 혼합하여 사용할 수 있습니다.

### 4.1 동적 락 목록 처리

동적으로 여러 개의 락을 획득해야 하는 경우(예: 여러 상품의 재고 락), 별도의 도우미 메서드를 사용하여 명시적으로 처리합니다.

```kotlin
@CompositeLock(
    locks = [
        DistributedLock(
            domain = LockKeyConstants.ORDER_PREFIX,
            resourceType = LockKeyConstants.RESOURCE_USER,
            resourceIdExpression = "criteria.userId"
        )
    ]
)
fun createOrder(criteria: OrderCriteria.Create): OrderResult.Single {
    // 상품 락은 동적으로 여러 개가 필요하므로 명시적으로 처리
    return withProductLocks(criteria.items.map { it.productId }) {
        // 비즈니스 로직
    }
}

private fun <T> withProductLocks(productIds: List<String>, action: () -> T): T {
    val productLockKeys = productIds.map { 
        LockKeyGenerator.Product.stockLock(it) 
    }.let {
        DistributedLockUtils.sortLockKeys(it)
    }
    
    return DistributedLockUtils.withOrderedLocks(
        lockManager = lockManager,
        keys = productLockKeys,
        timeouts = List(productLockKeys.size) { LockKeyConstants.DEFAULT_TIMEOUT },
        action = action
    )
}
```

## 5. 사용 가이드라인

### 5.1 단일 락과 복합 락 선택

- **단일 락**: 한 개의 리소스만 락이 필요한 간단한 메서드에는 `@DistributedLock` 사용
- **복합 락**: 고정된 여러 리소스에 락이 필요한 경우 `@CompositeLock` 사용
- **동적 복합 락**: 동적으로 여러 락이 필요한 경우 `@CompositeLock`과 명시적 코드 혼합 사용

### 5.2 타임아웃 설정

- 첫 번째 락: `LockKeyConstants.EXTENDED_TIMEOUT` (30초)
- 나머지 락: `LockKeyConstants.DEFAULT_TIMEOUT` (10초)

### 5.3 예외 처리

락 획득 실패 시 `LockAcquisitionException`이 발생합니다. 이 예외는 적절히 처리해야 합니다.

### 5.4 트랜잭션과의 관계

- 분산 락은 트랜잭션보다 먼저 획득되어야 합니다.
- 분산 락 AOP Aspect는 `@Order(Ordered.HIGHEST_PRECEDENCE)`로 설정되어 트랜잭션 시작 전에 실행됩니다.
- 트랜잭션 범위는 가능한 한 작게 유지하고, 락은 꼭 필요한 리소스에 대해서만 획득합니다.

## 6. 성능 고려사항

### 6.1 락 범위 최소화

- 락을 획득하는 시간은 최소화하고, 필요한 작업만 락 내에서 수행합니다.
- 외부 API 호출 등 시간이 오래 걸릴 수 있는 작업은 가능한 락 획득 전이나 락 해제 후에 수행합니다.

### 6.2 불필요한 락 획득 방지

- 읽기 전용 작업에는 락을 사용하지 않습니다.
- 독립적인 리소스 작업에는 불필요한 락을 획득하지 않습니다.

## 7. 도메인별 락 사용 예시

### 7.1 주문(Order) 도메인

```kotlin
// 주문 상태 업데이트
@DistributedLock(
    domain = LockKeyConstants.ORDER_PREFIX,
    resourceType = LockKeyConstants.RESOURCE_STATUS,
    resourceIdExpression = "orderId"
)
fun updateOrderStatus(orderId: String, status: OrderStatus): OrderResult.Single

// 주문 생성
@CompositeLock(
    locks = [
        DistributedLock(
            domain = LockKeyConstants.ORDER_PREFIX,
            resourceType = LockKeyConstants.RESOURCE_USER,
            resourceIdExpression = "criteria.userId"
        )
    ]
)
fun createOrder(criteria: OrderCriteria.Create): OrderResult.Single
```

### 7.2 상품(Product) 도메인

```kotlin
// 상품 재고 업데이트
@DistributedLock(
    domain = LockKeyConstants.PRODUCT_PREFIX,
    resourceType = LockKeyConstants.RESOURCE_STOCK,
    resourceIdExpression = "productId"
)
fun updateProductStock(productId: String, amount: Int): ProductResult.Single
```

### 7.3 사용자 포인트(UserPoint) 도메인

```kotlin
// 포인트 사용
@DistributedLock(
    domain = LockKeyConstants.USER_POINT_PREFIX,
    resourceType = LockKeyConstants.RESOURCE_USER,
    resourceIdExpression = "command.userId"
)
fun usePoint(command: UserPointCriteria.Use): UserPointResult.Single
```

## 8. 테스트

AOP 기반 분산 락 시스템은 적절한 테스트가 필요합니다.

### 8.1 단위 테스트

- 표현식에서 리소스 ID를 올바르게 추출하는지 테스트
- 락 획득 실패 시 예외 처리가 올바르게 되는지 테스트

### 8.2 통합 테스트

- 실제 분산 락 구현체와 함께 동작하는지 테스트
- 동시성 시나리오에서 락이 올바르게 작동하는지 테스트

## 9. 애노테이션 사용 시 주의사항

- `resourceIdExpression`이 null 값을 반환하지 않도록 주의합니다.
- 애노테이션은 `public` 메서드에만 사용합니다 (AOP 제한사항).
- 자기 호출(self-invocation) 시 AOP가 작동하지 않는 점에 주의합니다.
- 트랜잭션 애노테이션과 함께 사용할 때 순서에 주의합니다. 