# 7. 도메인 레이어 규약

## 1. 개요

본 문서는 Voyage-Shop 애플리케이션의 도메인(Domain) 레이어 개발 시 일관성을 유지하고, 코드 가독성 및 유지보수성을 향상시키기 위한 규약을 정의합니다. 모든 개발자는 본 규약을 숙지하고 준수하는 것을 원칙으로 합니다.

아키텍처 개요는 다음 문서들을 참조하세요:
- [1. 프로젝트 컨벤션 개요](./01.common-conventions.md)

## 목차

1. [도메인 엔티티](#1-도메인-엔티티)
2. [도메인 서비스](#2-도메인-서비스)
3. [리포지토리 인터페이스](#3-리포지토리-인터페이스)
4. [커맨드 패턴](#4-커맨드-패턴)
5. [예외 처리](#5-예외-처리)

## 1. 도메인 엔티티

### 1.1 정의

도메인 엔티티는 비즈니스 개념을 표현하는 객체로, 식별자(ID)를 통해 구분됩니다. 엔티티는 자신의 생명주기를 관리하고, 자신의 비즈니스 규칙을 캡슐화합니다.

### 1.2 명명 규칙

- 클래스 이름은 명사로 시작하며, 단수형을 사용합니다. (예: `User`, `Product`, `Order`)
- 엔티티의 식별자는 `{엔티티명}Id` 형식을 사용합니다. (예: `userId`, `productId`, `orderId`)
- 시간 관련 필드는 `createdAt`, `updatedAt` 등 일관된 형식을 사용합니다.

### 1.3 구조

```kotlin
data class User(
    val userId: String,
    val name: String,
    val email: String,
    val createdAt: LocalDateTime = LocalDateTime.now(),
    val updatedAt: LocalDateTime = LocalDateTime.now()
) {
    // 비즈니스 로직을 메서드로 구현
    fun validatePassword(password: String): Boolean {
        // 비즈니스 로직
    }
    
    // 불변성을 유지하면서 상태 변경하는 메서드
    fun updateEmail(newEmail: String): User {
        return this.copy(
            email = newEmail,
            updatedAt = LocalDateTime.now()
        )
    }
}
```

### 1.4 원칙

- 엔티티는 불변(immutable)으로 설계합니다. 상태 변경은 새 객체를 반환하는 메서드로 구현합니다.
  - **불변 설계의 장점**:
    - 스레드 안전성 보장: 동시성 문제 방지
    - 예측 가능한 동작: 상태 변경 추적 용이
    - 부작용 방지: 객체 상태의 일관성 유지
    - 비즈니스 규칙 중앙화: 상태 변경 로직이 메서드에 집중됨
  - **가변 필드(var) 사용 지양 이유**:
    - 객체의 일관성과 유효성 보장 어려움
    - 상태 변경 추적 불가능
    - 동시성 문제 발생 가능성
    - 테스트와 디버깅 복잡성 증가
- 비즈니스 로직은 엔티티 내부에 메서드로 구현합니다.
- 엔티티 간의 관계는 ID를 통해 표현합니다.
- 비즈니스 규칙 위반 시 적절한 도메인 예외를 발생시킵니다.

다음은 Product 엔티티의 예시입니다:

```kotlin
data class Product(
    val productId: String,
    val name: String,
    val price: Long,
    val stock: Long,
    val createdAt: LocalDateTime = LocalDateTime.now(),
    val updatedAt: LocalDateTime = LocalDateTime.now()
) {
    // 비즈니스 로직을 엔티티 내부에 구현
    fun decreaseStock(amount: Long): Product {
        // 비즈니스 규칙 검증은 엔티티 자체에서 처리
        if (stock < amount) {
            throw ProductException.StockAmountUnderflow(
                "Stock amount underflow for product: $productId"
            )
        }
        
        // 불변성을 유지하면서 새 객체 반환
        return this.copy(
            stock = stock - amount,
            updatedAt = LocalDateTime.now()
        )
    }
}
```

## 2. 도메인 서비스

### 2.1 정의

도메인 서비스는 특정 엔티티에 속하지 않는 비즈니스 로직을 구현하거나, 여러 엔티티 간의 조합 작업을 수행합니다.

### 2.2 명명 규칙

- 클래스 이름은 `{도메인}Service` 형식을 사용합니다. (예: `UserService`, `OrderService`)
- 메서드 이름은 동사 또는 동사구로 시작합니다. (예: `createUser`, `placeOrder`, `calculateDiscount`)

### 2.3 구조

```kotlin
@Service
class ProductService(
    private val productRepository: ProductRepository,
    private val stockCalculator: StockCalculator
) {
    fun getProduct(command: ProductCommand.GetById): Product {
        return productRepository.findById(command.productId)
            ?: throw ProductException.NotFound("Product with id: ${command.productId}")
    }
    
    fun decreaseStock(command: ProductCommand.DecreaseStock): Product {
        // 각 메서드는 직접 리포지토리에 접근
        val product = productRepository.findById(command.productId)
            ?: throw ProductException.NotFound("Product with id: ${command.productId}")
        
        // 비즈니스 검증 및 상태 변경은 엔티티에 위임
        val updatedProduct = product.decreaseStock(command.amount)
        
        // 업데이트된 엔티티 저장
        return productRepository.update(updatedProduct)
    }
}
```

### 2.4 원칙

- 도메인 서비스는 상태를 가지지 않는 것을 권장합니다.
- 트랜잭션 관리는 애플리케이션 레이어에서 담당합니다.
- 도메인 서비스는 리포지토리를 통해 영속성 레이어와 통신합니다.
- 커맨드 객체를 통해 요청을 받고 처리합니다.
- **중복 메서드를 절대 만들지 않습니다.** 동일한 기능을 수행하는 메서드는 하나만 존재해야 합니다.
- 메서드 이름은 그 역할을 명확히 표현해야 합니다. 단순히 내부 구현을 드러내는 이름(예: `process`, `handle`)보다는 비즈니스 의도를 드러내는 이름(예: `issueCoupon`, `calculateDiscount`)을 사용합니다.
- 메서드의 문서화(JavaDoc)를 통해 목적, 매개변수, 반환 값, 예외 등을 명확하게 설명합니다.
- **메서드 간 직접 호출을 지양합니다.** 각 메서드는 자신의 작업을 수행하기 위해 필요한 리포지토리에 직접 접근해야 합니다. 다른 서비스 메서드를 호출하면 코드의 복잡성이 증가하고 의존성이 깊어져 테스트와 유지보수가 어려워집니다.

### 2.5 메서드 설계 가이드라인

- **강력한 중복 방지 원칙**: 절대로 다음과 같은 중복 메서드를 만들지 않습니다:
  - 단순히 다른 메서드를 호출만 하는 메서드 (예: `getCouponUserWithValidation` → `getCouponUser`)
  - 이름만 다르고 동일한 기능을 하는 메서드 (예: `use` → `useCoupon`) 
  - 파라미터나 반환 타입이 동일하고 내부 구현이 거의 같은 메서드

- **private 메소드 피하기**: Private 메소드 사용은 되도록 피하도록 합니다.

- **단일 책임 원칙 준수**: 각 메서드는 하나의 명확한 책임만 가져야 합니다.

- **애매한 네이밍 금지**: `process`, `handle`, `execute`와 같은 구체적이지 않은 이름은 지양합니다. 대신 `issueCoupon`, `calculateDiscount`, `validateOrder`와 같이 기능을 명확히 설명하는 이름을 사용합니다.

- **독립적인 메서드 설계**: 각 메서드는 다른 서비스 메서드에 의존하지 않고 독립적으로 동작해야 합니다. 공통 로직이 필요한 경우, 컴포넌트를 선언하여 사용하도록 합니다. 

#### 좋은 예시:

```kotlin
// 좋은 예시: 명확한 이름으로 하나의 메서드만 제공
fun issueCoupon(command: CouponCommand.Create): Coupon {
    // 쿠폰 발급 로직
}


// 좋은 예시: 각 메서드가 독립적으로 리포지토리에 접근
fun useCoupon(command: CouponUserCommand.Use): CouponUser {
    // 다른 서비스 메서드 호출 대신 직접 리포지토리 접근
    val couponUser = repository.findById(command.couponUserId)
        ?: throw CouponException.NotFound("Coupon with id: ${command.couponUserId}")
        
    val usedCouponUser = couponUser.use()
    return repository.update(usedCouponUser)
}
```

#### 절대 하지 말아야 할 나쁜 예시:

```kotlin
// 나쁜 예시 1: 유사한 기능을 수행하는 중복 메서드
fun use(command: CouponCommand.Use): Coupon {
    // 쿠폰 사용 로직
}

fun useCoupon(command: CouponCommand.Use): Coupon {
    return use(command) // 단순히 다른 메서드 호출
}

// 아래 메서드는 완전히 불필요함!
fun getCouponUserWithValidation(command: CouponUserCommand.GetById): CouponUser {
    return getCouponUser(command) // 단순 위임만 수행
}

// 나쁜 예시 3: 애매한 이름의 메서드
fun process(command: OrderCommand.Process): Order {
    // 어떤 처리를 하는지 이름만으로는 명확하지 않음
}

// 나쁜 예시 4: 메서드 간 직접 호출
fun calculateDiscountAmount(command: CouponUserCommand.CalculateDiscount): Long {
    // 다른 서비스 메서드를 호출하여 의존성 발생
    val couponUser = getCouponUser(CouponUserCommand.GetById(command.couponUserId))
    
    return couponUser.calculateDiscountAmount(command.originalAmount)
}
```

위 나쁜 예시들은 코드의 복잡성을 증가시키고 유지보수를 어렵게 만듭니다. 항상 메서드 하나가 명확한 하나의 책임을 가지도록 설계하고, 불필요한 중복을 제거하며, 메서드 간 직접 호출을 지양하는 것이 중요합니다.

## 3. 리포지토리 인터페이스

### 3.1 정의

리포지토리는 도메인 객체의 영속성을 담당하는 인터페이스입니다. 도메인 레이어에서는 리포지토리 인터페이스만 정의하고, 구현체는 인프라스트럭처 레이어에 위치합니다.

### 3.2 명명 규칙

- 인터페이스 이름은 `{도메인}Repository` 형식을 사용합니다. (예: `UserRepository`, `OrderRepository`)
- 메서드 이름은 `findById`, `findByUserId`, `create`, `update`, `delete` 등 일관된 명명을 사용합니다.

### 3.3 구조

```kotlin
interface ProductRepository {
    fun findById(productId: String): Product?
    fun findAll(): List<Product>
    fun create(product: Product): Product
    fun update(product: Product): Product
    fun delete(productId: String)
    fun findByCategory(categoryId: String): List<Product>
}
```

### 3.4 원칙

- 리포지토리는 데이터베이스 접근 세부 사항을 숨깁니다.
- 리포지토리 메서드는 도메인 객체와 ID만을 파라미터로 사용합니다.
- 페이징, 정렬 등의 기능은 객체 파라미터로 전달합니다.
- 리포지토리는 도메인 객체만 반환하며, 되도록 DTO를 반환하지 않습니다.

## 4. 커맨드 패턴

### 4.1 정의

커맨드 패턴은 요청을 객체로 캡슐화하여 요청에 필요한 모든 정보를 포함하고, 검증 로직을 중앙화하며, 메서드 호출을 일관성 있게 만드는 데 도움이 됩니다.

### 4.2 명명 규칙

- 커맨드 클래스는 `{도메인}Command` 형식으로 명명합니다. (예: `UserCommand`, `OrderCommand`)
- 내부 클래스는 수행할 작업을 명확히 표현합니다. (예: `GetById`, `Create`, `Update`, `Delete` 등)

### 4.3 기본 구조

```kotlin
sealed class ProductCommand {
    data class GetById(val productId: String) : ProductCommand() {
        init {
            if (productId.isBlank()) {
                throw ProductException.ProductIdShouldNotBlank("Product ID should not be blank")
            }
        }
    }
    
    data class Create(
        val name: String,
        val price: Long,
        val stock: Long
    ) : ProductCommand() {
        init {
            if (name.isBlank()) {
                throw ProductException.NameShouldNotBlank("Product name should not be blank")
            }
            if (price <= 0) {
                throw ProductException.PriceShouldMoreThan0("Price should be more than 0")
            }
            if (stock < 0) {
                throw ProductException.StockShouldNotNegative("Stock should not be negative")
            }
        }
        
        fun toEntity(): Product {
            return Product(
                productId = UUID.randomUUID().toString(),
                name = name,
                price = price,
                stock = stock,
                createdAt = LocalDateTime.now(),
                updatedAt = LocalDateTime.now()
            )
        }
    }
    
    data class DecreaseStock(
        val productId: String,
        val amount: Long
    ) : ProductCommand() {
        init {
            if (productId.isBlank()) {
                throw ProductException.ProductIdShouldNotBlank("Product ID should not be blank")
            }
            if (amount <= 0) {
                throw ProductException.AmountShouldMoreThan0("Amount should be more than 0")
            }
        }
    }
}
```

### 4.4 원칙

- 모든 커맨드는 `sealed class` 내부에 정의합니다.
- 각 커맨드는 필요한 모든 데이터를 포함해야 합니다.
- 검증 로직은 커맨드 객체의 `init` 블록에서 수행합니다.
- 도메인 서비스 메서드는 커맨드 객체를 파라미터로 받아 처리합니다.

## 5. 예외 처리

### 5.1 정의

도메인 레이어에서는 비즈니스 규칙 위반이나 도메인 로직 처리 중 발생하는 오류를 표현하기 위해 도메인 예외를 사용합니다.

### 5.2 명명 규칙

- 도메인 예외 클래스는 `{도메인}Exception` 형식으로 명명합니다. (예: `UserException`, `OrderException`)
- 내부 예외 클래스는 발생 원인을 명확히 표현합니다. (예: `NotFound`, `AlreadyExists`, `InvalidState` 등)

### 5.3 원칙

- 모든 도메인 예외는 `AbstractDomainException`을 상속받아 구현합니다.
- 예외 클래스는 도메인 별로 그룹화합니다.
- 에러 코드는 도메인 접두사(prefix)를 사용하여 정의합니다. (예: `PRODUCT_`, `USER_`, `ORDER_` 등)
- 예외 클래스는 기본적으로 메시지를 인자로 받고, 필요한 경우 추가 인자를 받을 수 있습니다.
- 예외 메시지는 명확하고 구체적으로 작성합니다.
- 예외는 발생 즉시 처리하지 않고, 상위 레이어로 전파하여 처리합니다.

### 5.4 에러 코드 명명 규칙

에러 코드는 다음 규칙에 따라 명명합니다:

1. **도메인 접두사**: 각 에러 코드는 해당 도메인의 접두사로 시작합니다. (예: `PRODUCT_`, `USER_`, `ORDER_`)

2. **카테고리**: 에러의 유형을 나타내는 카테고리를 포함합니다. 일반적인 카테고리는 다음과 같습니다:
   - `NOT_FOUND`: 리소스를 찾을 수 없음
   - `INVALID`: 유효하지 않은 입력 또는 상태
   - `DUPLICATE`: 중복된 데이터
   - `FORBIDDEN`: 접근 권한 문제
   - `CONFLICT`: 리소스 상태 충돌

3. **세부 정보**: 필요한 경우 추가적인 세부 정보를 포함합니다. (예: `STOCK_UNDERFLOW`, `EMAIL_EXISTS`)

예시:
- `PRODUCT_NOT_FOUND`: 상품을 찾을 수 없음
- `PRODUCT_INVALID_PRICE`: 유효하지 않은 상품 가격
- `USER_DUPLICATE_EMAIL`: 중복된 이메일 주소
- `ORDER_INVALID_STATUS_TRANSITION`: 유효하지 않은 주문 상태 전환

복합적인 도메인의 경우 하위 도메인을 포함할 수 있습니다:
- `PAYMENT_CARD_INVALID_NUMBER`: 결제 카드의 유효하지 않은 번호
- `SHIPPING_ADDRESS_INVALID_ZIPCODE`: 배송 주소의 유효하지 않은 우편번호

#### 에러 코드 작성 팁

1. **명확성과 구체성**: 에러 코드는 발생한 문제를 명확하게 식별할 수 있어야 합니다.
2. **일관성**: 유사한 문제에는 유사한 패턴의 에러 코드를 사용합니다.
3. **간결성**: 에러 코드는 간결하면서도 설명적이어야 합니다.
4. **영어 사용**: 에러 코드는 영어 대문자와 언더스코어(`_`)만 사용합니다.
5. **복수형 지양**: 단수형을 사용합니다 (예: `USER_NOT_FOUND`가 `USERS_NOT_FOUND`보다 선호됨).

### 5.5 AbstractDomainException 활용

모든 도메인 예외는 `AbstractDomainException`을 상속받아 구현해야 합니다. 이는 일관된 예외 처리와 에러 응답 구조를 제공하기 위함입니다.

```kotlin
sealed class ProductException {
    /**
     * 요청한 상품을 찾을 수 없을 때 발생하는 예외
     * 주로 상품 ID로 조회 시 해당 상품이 존재하지 않는 경우 사용
     */
    class NotFound(message: String, val id: String? = null) : AbstractDomainException(
        errorCode = "PRODUCT_NOT_FOUND",
        errorMessage = message
    )
    
    /**
     * 상품의 재고가 충분하지 않을 때 발생하는 예외
     * 주문 처리 시 요청한 수량이 가용 재고보다 많은 경우 사용
     */
    class InsufficientStock(
        message: String, 
        val productId: String? = null, 
        val requested: Long? = null, 
        val available: Long? = null
    ) : AbstractDomainException(
        errorCode = "PRODUCT_STOCK_INSUFFICIENT",
        errorMessage = message
    )
    
    /**
     * 상품 가격이 유효하지 않을 때 발생하는 예외
     * 상품 가격이 음수이거나 최소 가격 요구사항을 충족하지 않는 경우 사용
     */
    class InvalidPrice(message: String, val price: Long? = null) : AbstractDomainException(
        errorCode = "PRODUCT_PRICE_INVALID",
        errorMessage = message
    )
}

sealed class UserException {
    /**
     * 요청한 사용자를 찾을 수 없을 때 발생하는 예외
     * 사용자 ID로 조회 시 해당 사용자가 존재하지 않는 경우 사용
     */
    class NotFound(message: String, val id: String? = null) : AbstractDomainException(
        errorCode = "USER_NOT_FOUND",
        errorMessage = message
    )
    
    /**
     * 이미 사용 중인 이메일로 사용자를 생성하려 할 때 발생하는 예외
     * 사용자 등록 시 이메일 중복 검사에서 실패한 경우 사용
     */
    class DuplicateEmail(message: String, val email: String? = null) : AbstractDomainException(
        errorCode = "USER_EMAIL_DUPLICATE",
        errorMessage = message
    )
}

sealed class OrderException {
    /**
     * 요청한 주문을 찾을 수 없을 때 발생하는 예외
     * 주문 ID로 조회 시 해당 주문이 존재하지 않는 경우 사용
     */
    class NotFound(message: String, val id: String? = null) : AbstractDomainException(
        errorCode = "ORDER_NOT_FOUND",
        errorMessage = message
    )
    
    /**
     * 주문 상태가 요청한 작업에 적합하지 않을 때 발생하는 예외
     * 예: 이미 취소된 주문을 배송 처리하려는 경우
     */
    class InvalidStatus(
        message: String, 
        val orderId: String? = null, 
        val currentStatus: String? = null, 
        val requiredStatus: String? = null
    ) : AbstractDomainException(
        errorCode = "ORDER_STATUS_INVALID",
        errorMessage = message
    )
}
```

사용 예시:

```kotlin
// 기본 메시지만 전달하는 경우
throw ProductException.NotFound("상품을 찾을 수 없습니다.")

// 추가 정보와 함께 예외 발생
throw ProductException.NotFound("상품을 찾을 수 없습니다: $productId", productId)

// 여러 인자와 함께 상세한 예외 정보 제공
throw ProductException.InsufficientStock(
    "재고가 부족합니다",
    productId = "PROD-123",
    requested = 10,
    available = 5
)
```

이렇게 구현하면 모든 도메인 예외가 동일한 구조를 가지며, 도메인별 접두사가 있는 에러 코드와 에러 메시지를 일관되게 제공할 수 있습니다. 에러 코드의 접두사를 통해 어느 도메인에서 발생한 예외인지 쉽게 식별할 수 있습니다. 