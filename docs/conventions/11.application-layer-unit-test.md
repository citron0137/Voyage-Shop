# 11. 애플리케이션 레이어 유닛 테스트 컨벤션

## 1. 개요

본 문서는 Voyage-Shop 애플리케이션의 애플리케이션 레이어 유닛 테스트 작성 시 일관성을 유지하고, 테스트 품질을 향상시키기 위한 규약을 정의합니다. 모든 개발자는 본 규약을 숙지하고 준수하는 것을 원칙으로 합니다.

애플리케이션 레이어 유닛 테스트의 목적은 여러 도메인 서비스를 조합하는 유스케이스가 올바르게 동작하는지 검증하는 것입니다. 이 테스트는 도메인 서비스와의 상호작용 및 트랜잭션 관리를 중점적으로 검증합니다.

## 2. 테스트 디렉토리 구조

```
src/test/kotlin/kr/hhplus/be/server/
└── application/                # 애플리케이션 레이어 테스트
    ├── user/                   # 사용자 애플리케이션 테스트
    │   └── UserFacadeTest.kt   # 사용자 퍼사드 테스트
    ├── order/                  # 주문 애플리케이션 테스트
    │   └── OrderFacadeTest.kt  # 주문 퍼사드 테스트
    └── ...                     # 기타 애플리케이션 테스트
```

## 3. 테스트 네이밍 규칙

### 3.1 클래스 네이밍

- 퍼사드 테스트: `{도메인명}FacadeTest` (예: `UserFacadeTest`)
- 애플리케이션 서비스 테스트: `{도메인명}ApplicationServiceTest` (예: `OrderApplicationServiceTest`)

### 3.2 메서드 네이밍

테스트 메소드명은 모두 영어로 작성하고, `@DisplayName`으로 한글 제목을 지정합니다.

```kotlin
@Test
@DisplayName("유효한 쿠폰을 사용하여 주문 금액이 할인되어야 한다")
fun applyValidCouponToOrder_shouldDiscountOrderAmount() {
    // 테스트 코드
}
```

### 3.3 메서드 네이밍 패턴

메서드 이름은 다음 패턴을 따릅니다:

1. `{시나리오}_{기대결과}` 형식 권장
   - 예: `applyValidCouponToOrder_shouldDiscountOrderAmount`

2. 유스케이스 중심의 명명법
   - 예: `placeOrderWithInsufficientPointsTest`
   - 예: `registerUserAndCreatePointTest`

## 4. 테스트 구조

### 4.1 기본 구조

모든 테스트는 Given-When-Then 패턴을 따라 구성합니다:

```kotlin
@Test
@DisplayName("유효한 포인트를 사용하여 주문 시 포인트가 차감되어야 한다")
fun useValidPointsWhenPlacingOrder_shouldDeductPoints() {
    // given: 테스트 사전 조건 설정
    val userId = "user1"
    val orderAmount = 10000L
    val usePoints = 1000L
    
    val user = User(userId)
    val userPoint = UserPoint(userId, 2000)
    
    every { userService.findById(userId) } returns user
    every { userPointService.findByUserId(userId) } returns userPoint
    every { userPointService.use(any()) } returns userPoint.copy(point = 1000)
    every { orderService.createOrder(any()) } returns Order("order1", userId, 9000)
    
    // when: 테스트 대상 메서드 실행
    val result = orderFacade.placeOrder(OrderCriteria.Create(
        userId = userId,
        totalAmount = orderAmount,
        usePoints = usePoints
    ))
    
    // then: 결과 검증
    assertEquals(9000, result.finalAmount)
    verify { userPointService.use(match { it.amount == 1000L }) }
}
```

### 4.2 주석 처리

- 각 단계를 명확히 구분하기 위해 `// given:`, `// when:`, `// then:` 주석을 사용합니다.
- 각 단계가 복잡한 경우 세부 설명을 주석으로 추가하여 테스트의 의도를 명확히 합니다.

## 5. Mock 사용

### 5.1 Mock 객체 설정

애플리케이션 레이어 테스트에서는 도메인 서비스를 Mock으로 대체합니다:

```kotlin
@ExtendWith(MockKExtension::class)
class OrderFacadeTest {
    @MockK
    private lateinit var orderService: OrderService
    
    @MockK
    private lateinit var userService: UserService
    
    @MockK
    private lateinit var userPointService: UserPointService
    
    @InjectMockKs
    private lateinit var orderFacade: OrderFacade
    
    @BeforeEach
    fun setUp() {
        MockKAnnotations.init(this)
    }
    
    // 테스트 메서드
}
```

### 5.2 Stubbing 전략

애플리케이션 레이어 테스트에서는 다음 Stubbing 전략을 사용합니다:

1. **필요한 응답만 Stubbing**: 테스트에 필요한 메서드 호출에 대해서만 Stubbing
2. **상황별 응답 설정**: 다양한 시나리오를 테스트하기 위해 상황별 응답 설정
3. **예외 시나리오 처리**: 도메인 서비스에서 발생할 수 있는 예외 시나리오 설정

```kotlin
// 기본 Stubbing
every { userService.findById(userId) } returns user

// 조건부 Stubbing
every { userPointService.use(match { it.amount <= userPoint.point }) } returns userPoint.copy(point = userPoint.point - it.amount)
every { userPointService.use(match { it.amount > userPoint.point }) } throws InsufficientPointsException()

// 예외 시나리오
every { orderService.findById("non-existent-id") } returns null
```

### 5.3 Verification

중요한 협력 객체 호출은 반드시 verify를 통해 검증합니다:

```kotlin
// 호출 여부 검증
verify { orderService.createOrder(any()) }

// 호출 횟수 검증
verify(exactly = 1) { userPointService.use(any()) }

// 호출 순서 검증
verifyOrder {
    userPointService.use(any())
    orderService.createOrder(any())
}

// 인자 검증
verify { orderService.createOrder(match { 
    it.userId == userId && it.finalAmount == orderAmount - usePoints 
}) }

// 호출되지 않음 검증
verify(exactly = 0) { emailService.sendOrderConfirmation(any()) }
```

## 6. 트랜잭션 테스트

애플리케이션 레이어에서는 트랜잭션 관리가 중요한 책임이므로, 다음 시나리오를 테스트합니다:

### 6.1 성공 시나리오

트랜잭션이 정상적으로 커밋되는 성공 시나리오:

```kotlin
@Test
@DisplayName("포인트 사용과 주문 생성이 모두 성공하면 트랜잭션이 커밋되어야 한다")
fun placeOrderWithPoints_allOperationsSucceed_shouldCommitTransaction() {
    // given
    // Mock 설정
    
    // when
    orderFacade.placeOrderWithPoints(/* 파라미터 */)
    
    // then
    verify { orderService.createOrder(any()) }
    verify { userPointService.use(any()) }
    // 트랜잭션 커밋은 직접 검증할 수 없으므로, 메서드 호출 검증으로 대체
}
```

### 6.2 실패 시나리오

트랜잭션이 롤백되는 실패 시나리오:

```kotlin
@Test
@DisplayName("주문 생성 중 오류 발생 시 포인트 차감이 롤백되어야 한다")
fun placeOrderWithPoints_orderCreationFails_shouldRollbackPointDeduction() {
    // given
    val userId = "user1"
    val orderAmount = 10000L
    val usePoints = 1000L
    
    every { userPointService.use(any()) } returns mockk()
    every { orderService.createOrder(any()) } throws RuntimeException("주문 생성 실패")
    
    // when & then
    assertThrows<RuntimeException> {
        orderFacade.placeOrder(OrderCriteria.Create(
            userId = userId,
            totalAmount = orderAmount,
            usePoints = usePoints
        ))
    }
    
    // 롤백은 직접 검증할 수 없으므로, 예외 발생을 검증하는 것으로 대체
}
```

## 7. Result 객체 변환 테스트

애플리케이션 레이어에서는 도메인 객체를 Result 객체로 변환하는 로직을 테스트합니다:

```kotlin
@Test
@DisplayName("도메인 객체가 올바르게 Result 객체로 변환되어야 한다")
fun convertDomainObjectToResult_shouldMapCorrectly() {
    // given
    val order = Order(
        orderId = "order1",
        userId = "user1",
        totalAmount = 10000,
        discountAmount = 1000,
        finalAmount = 9000,
        status = OrderStatus.CREATED,
        createdAt = LocalDateTime.now(),
        updatedAt = LocalDateTime.now()
    )
    
    every { orderService.findById("order1") } returns order
    
    // when
    val result = orderFacade.findOrderById(OrderCriteria.GetById("order1"))
    
    // then
    assertEquals(order.orderId, result.orderId)
    assertEquals(order.userId, result.userId)
    assertEquals(order.totalAmount, result.totalAmount)
    assertEquals(order.discountAmount, result.discountAmount)
    assertEquals(order.finalAmount, result.finalAmount)
    assertEquals(order.status.name, result.status)
}
```

## 8. 예외 처리 테스트

### 8.1 도메인 예외 전파

도메인 레이어에서 발생한 예외가 적절히 전파되는지 테스트:

```kotlin
@Test
@DisplayName("도메인 예외가 발생하면 그대로 전파되어야 한다")
fun domainExceptionShouldPropagateAsIs() {
    // given
    val userId = "user1"
    val invalidProductId = "invalid-product"
    
    every { productService.findById(invalidProductId) } throws ProductNotFoundException("상품을 찾을 수 없습니다")
    
    // when & then
    val exception = assertThrows<ProductNotFoundException> {
        orderFacade.placeOrder(OrderCriteria.Create(
            userId = userId,
            items = listOf(OrderItemCriteria.Create(productId = invalidProductId, quantity = 1))
        ))
    }
    
    assertEquals("상품을 찾을 수 없습니다", exception.message)
}
```

### 8.2 애플리케이션 레이어 예외 처리

애플리케이션 레이어에서 처리하는 예외가 올바르게 처리되는지 테스트:

```kotlin
@Test
@DisplayName("동일한 쿠폰을 중복 적용하려고 할 때 예외가 발생해야 한다")
fun applyDuplicateCoupon_shouldThrowException() {
    // given
    val orderId = "order1"
    val couponId = "coupon1"
    
    every { orderService.findById(orderId) } returns mockk()
    every { orderDiscountService.findByOrderIdAndDiscountId(orderId, couponId) } returns mockk()
    
    // when & then
    assertThrows<DuplicateCouponException> {
        orderFacade.applyCoupon(OrderCriteria.ApplyCoupon(
            orderId = orderId,
            couponId = couponId
        ))
    }
}
```

## 9. 복잡한 유스케이스 테스트

### 9.1 다중 서비스 조합

여러 도메인 서비스를 조합하는 복잡한 유스케이스 테스트:

```kotlin
@Test
@DisplayName("새로운 사용자 등록 시 포인트가 생성되고 쿠폰이 발급되어야 한다")
fun registerNewUser_shouldCreatePointAndIssueCoupon() {
    // given
    val userCommand = UserCommand.Create(
        email = "test@example.com",
        password = "password"
    )
    val createdUser = User("user1", "test@example.com", LocalDateTime.now(), LocalDateTime.now())
    val createdPoint = UserPoint("user1", 1000)
    val couponEvent = CouponEvent("event1", BenefitMethod.DISCOUNT_FIXED_AMOUNT, "1000", 100, 99)
    val issuedCoupon = CouponUser("coupon1", "user1", BenefitMethod.DISCOUNT_FIXED_AMOUNT, "1000", null)
    
    every { userService.createUser(any()) } returns createdUser
    every { userPointService.create(any()) } returns createdPoint
    every { couponEventService.findWelcomeCouponEvent() } returns couponEvent
    every { couponUserService.issue(any()) } returns issuedCoupon
    
    // when
    val result = userFacade.registerUser(UserCriteria.Register(
        email = "test@example.com",
        password = "password"
    ))
    
    // then
    assertEquals(createdUser.userId, result.userId)
    verify { userService.createUser(any()) }
    verify { userPointService.create(match { it.userId == "user1" && it.initialPoint == 1000 }) }
    verify { couponUserService.issue(match { it.userId == "user1" && it.couponEventId == "event1" }) }
}
```

### 9.2 분기 처리 테스트

조건에 따른 분기 처리가 있는 경우의 테스트:

```kotlin
@Test
@DisplayName("VIP 사용자는 추가 할인이 적용되어야 한다")
fun applyDiscount_forVipUser_shouldApplyAdditionalDiscount() {
    // given
    val userId = "user1"
    val orderAmount = 10000L
    
    val user = User(userId, grade = UserGrade.VIP)
    
    every { userService.findById(userId) } returns user
    every { discountPolicyService.calculateDiscount(any(), any()) } answers {
        val user = firstArg<User>()
        val amount = secondArg<Long>()
        if (user.grade == UserGrade.VIP) amount * 0.1 else amount * 0.05
    }
    every { orderService.createOrder(any()) } answers { 
        val command = firstArg<OrderCommand.Create>()
        Order(
            orderId = "order1", 
            userId = command.userId, 
            totalAmount = command.totalAmount, 
            discountAmount = command.discountAmount, 
            finalAmount = command.totalAmount - command.discountAmount
        )
    }
    
    // when
    val result = orderFacade.placeOrder(OrderCriteria.Create(
        userId = userId,
        totalAmount = orderAmount
    ))
    
    // then
    assertEquals(1000, result.discountAmount) // 10% 할인 (VIP)
    assertEquals(9000, result.finalAmount)
}

@Test
@DisplayName("일반 사용자는 기본 할인만 적용되어야 한다")
fun applyDiscount_forRegularUser_shouldApplyBasicDiscount() {
    // given
    val userId = "user1"
    val orderAmount = 10000L
    
    val user = User(userId, grade = UserGrade.REGULAR)
    
    every { userService.findById(userId) } returns user
    every { discountPolicyService.calculateDiscount(any(), any()) } answers {
        val user = firstArg<User>()
        val amount = secondArg<Long>()
        if (user.grade == UserGrade.VIP) amount * 0.1 else amount * 0.05
    }
    every { orderService.createOrder(any()) } answers { 
        val command = firstArg<OrderCommand.Create>()
        Order(
            orderId = "order1", 
            userId = command.userId, 
            totalAmount = command.totalAmount, 
            discountAmount = command.discountAmount, 
            finalAmount = command.totalAmount - command.discountAmount
        )
    }
    
    // when
    val result = orderFacade.placeOrder(OrderCriteria.Create(
        userId = userId,
        totalAmount = orderAmount
    ))
    
    // then
    assertEquals(500, result.discountAmount) // 5% 할인 (일반)
    assertEquals(9500, result.finalAmount)
}
```

## 10. 테스트 데이터 관리

### 10.1 테스트 데이터 팩토리

반복적으로 사용되는 테스트 데이터는 팩토리 메서드를 통해 생성합니다:

```kotlin
private fun createTestUser(userId: String = "user1", grade: UserGrade = UserGrade.REGULAR): User {
    return User(
        userId = userId,
        email = "$userId@example.com",
        grade = grade,
        createdAt = LocalDateTime.now(),
        updatedAt = LocalDateTime.now()
    )
}

private fun createTestOrder(
    orderId: String = "order1",
    userId: String = "user1",
    totalAmount: Long = 10000,
    discountAmount: Long = 0
): Order {
    return Order(
        orderId = orderId,
        userId = userId,
        totalAmount = totalAmount,
        discountAmount = discountAmount,
        finalAmount = totalAmount - discountAmount,
        status = OrderStatus.CREATED,
        createdAt = LocalDateTime.now(),
        updatedAt = LocalDateTime.now()
    )
}
```

### 10.2 테스트 케이스 클래스

복잡한 테스트 케이스는 별도의 데이터 클래스로 정의합니다:

```kotlin
private data class DiscountTestCase(
    val description: String,
    val userGrade: UserGrade,
    val orderAmount: Long,
    val expectedDiscountRate: Double,
    val expectedDiscountAmount: Long,
    val expectedFinalAmount: Long
)

@ParameterizedTest
@DisplayName("사용자 등급별 할인율이 올바르게 적용되어야 한다")
@MethodSource("discountTestCases")
fun applyDiscount_byUserGrade_shouldApplyCorrectRate(testCase: DiscountTestCase) {
    // given
    val userId = "user1"
    val user = createTestUser(userId = userId, grade = testCase.userGrade)
    
    every { userService.findById(userId) } returns user
    every { discountPolicyService.calculateDiscount(any(), any()) } answers {
        val user = firstArg<User>()
        val amount = secondArg<Long>()
        (amount * testCase.expectedDiscountRate).toLong()
    }
    every { orderService.createOrder(any()) } answers { /* mapping logic */ }
    
    // when
    val result = orderFacade.placeOrder(OrderCriteria.Create(
        userId = userId,
        totalAmount = testCase.orderAmount
    ))
    
    // then
    assertEquals(testCase.expectedDiscountAmount, result.discountAmount)
    assertEquals(testCase.expectedFinalAmount, result.finalAmount)
}

private fun discountTestCases() = Stream.of(
    DiscountTestCase(
        description = "VIP 사용자 10% 할인",
        userGrade = UserGrade.VIP,
        orderAmount = 10000,
        expectedDiscountRate = 0.1,
        expectedDiscountAmount = 1000,
        expectedFinalAmount = 9000
    ),
    DiscountTestCase(
        description = "GOLD 사용자 7% 할인",
        userGrade = UserGrade.GOLD,
        orderAmount = 10000,
        expectedDiscountRate = 0.07,
        expectedDiscountAmount = 700,
        expectedFinalAmount = 9300
    ),
    DiscountTestCase(
        description = "REGULAR 사용자 5% 할인",
        userGrade = UserGrade.REGULAR,
        orderAmount = 10000,
        expectedDiscountRate = 0.05,
        expectedDiscountAmount = 500,
        expectedFinalAmount = 9500
    )
)
```

## 11. 애플리케이션 레이어 단위 테스트 컨벤션

애플리케이션 레이어는 다음 수준의 테스트 커버리지를 목표로 합니다:

1. **클래스 커버리지**: 100% (모든 Facade 클래스는 테스트 대상)
2. **메서드 커버리지**: 90% 이상
3. **라인 커버리지**: 85% 이상
4. **분기 커버리지**: 80% 이상 (주요 조건 분기는 모두 테스트) 