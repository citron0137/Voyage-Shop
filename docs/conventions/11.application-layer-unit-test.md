# 11. 애플리케이션 레이어 유닛 테스트 컨벤션

## 1. 개요

본 문서는 Voyage-Shop 애플리케이션의 애플리케이션 레이어 유닛 테스트 작성 규약을 정의합니다. 이 문서는 [09. 테스트 컨벤션](./09.test-conventions.md) 문서의 규약을 기반으로 합니다.

애플리케이션 레이어 유닛 테스트의 목적은 여러 도메인 서비스를 조합하는 유스케이스가 올바르게 동작하는지 검증하는 것입니다. 이 테스트는 도메인 서비스와의 상호작용 및 트랜잭션 관리를 중점적으로 검증합니다.

## 2. 테스트 디렉토리 구조

```
src/test/kotlin/kr/hhplus/be/server/
└── application/                # 애플리케이션 레이어 테스트
    ├── unit/                   # 애플리케이션 단위 테스트
    │   ├── user/               # 사용자 애플리케이션 테스트
    │   │   └── UserFacadeTest.kt  # 사용자 퍼사드 테스트
    │   └── order/              # 주문 애플리케이션 테스트
    │       └── OrderFacadeTest.kt # 주문 퍼사드 테스트
    └── ...                     # 기타 애플리케이션 테스트
```

## 3. 테스트 클래스 구성

### 3.1 클래스 네이밍 규칙

- 퍼사드 테스트: `{도메인명}FacadeTest` (예: `UserFacadeTest`)
- 애플리케이션 서비스 테스트: `{도메인명}ApplicationServiceTest` (예: `OrderApplicationServiceTest`)

### 3.2 중첩 객체 활용 (필수)

모든 테스트 클래스는 JUnit5의 `@Nested` 애노테이션을 사용하여 계층적으로 구조화해야 합니다.

```kotlin
@DisplayName("주문 퍼사드 테스트")
class OrderFacadeTest {

    @MockK
    private lateinit var orderService: OrderService
    
    @MockK
    private lateinit var userService: UserService
    
    @MockK
    private lateinit var userPointService: UserPointService
    
    @InjectMockKs
    private lateinit var orderFacade: OrderFacade
    
    @BeforeEach
    fun setUp() {
        MockKAnnotations.init(this)
    }

    @Nested
    @DisplayName("주문 생성 시")
    inner class OrderCreation {
        // 주문 생성 관련 테스트 메서드들
    }
    
    @Nested
    @DisplayName("포인트 사용 시")
    inner class PointUsage {
        // 포인트 사용 관련 테스트 메서드들
    }
    
    @Nested
    @DisplayName("쿠폰 적용 시")
    inner class CouponApplication {
        // 쿠폰 적용 관련 테스트 메서드들
    }
}
```

## 4. 테스트 메서드 구성

### 4.1 메서드 네이밍 규칙

중첩 클래스 내 메서드는 `{조건}_{기대결과}` 형식으로 작성합니다:

```kotlin
@Nested
@DisplayName("주문 생성 시")
inner class OrderCreation {
    
    @Test
    @DisplayName("정상적인 상품으로 주문 생성이 성공해야 한다")
    fun withValidProduct_succeeds() {
        // 테스트 코드
    }
    
    @Test
    @DisplayName("충분한 포인트로 결제 시 포인트가 차감되어야 한다")
    fun withSufficientPoints_deductsPoints() {
        // 테스트 코드
    }
}
```

### 4.2 기본 테스트 구조

모든 테스트는 Given-When-Then 패턴을 따릅니다.

## 5. Mock 객체 활용

### 5.1 Mock 객체 설정

애플리케이션 레이어 테스트에서는 도메인 서비스를 Mock으로 대체합니다:

```kotlin
@MockK
private lateinit var orderService: OrderService

@MockK
private lateinit var userService: UserService

@BeforeEach
fun setUp() {
    MockKAnnotations.init(this)
    clearAllMocks()
}
```

### 5.2 Stubbing 전략

애플리케이션 레이어 테스트에서는 다음 Stubbing 전략을 사용합니다:

1. 필요한 응답만 Stubbing: 테스트에 필요한 메서드 호출에 대해서만 Stubbing
2. 상황별 응답 설정: 다양한 시나리오를 테스트하기 위해 상황별 응답 설정
3. 예외 시나리오 처리: 도메인 서비스에서 발생할 수 있는 예외 시나리오 설정

```kotlin
// 기본 Stubbing
every { userService.findById(userId) } returns user

// 조건부 Stubbing
every { userPointService.use(match { it.amount <= userPoint.point }) } returns 
    userPoint.copy(point = userPoint.point - it.amount)
every { userPointService.use(match { it.amount > userPoint.point }) } throws 
    InsufficientPointsException()
```

### 5.3 Verification

중요한 협력 객체 호출은 반드시 verify를 통해 검증합니다:

```kotlin
// 호출 여부 검증
verify { orderService.createOrder(any()) }

// 호출 횟수 검증
verify(exactly = 1) { userPointService.use(any()) }

// 인자 검증
verify { orderService.createOrder(match { 
    it.userId == userId && it.finalAmount == orderAmount - usePoints 
}) }
```

## 6. 애플리케이션 레이어 특화 테스트

### 6.1 트랜잭션 테스트

애플리케이션 레이어에서는 트랜잭션 관리가 중요한 책임이므로, 다음 시나리오를 테스트합니다:

- 성공 시나리오: 모든 작업이 성공적으로 완료되는 경우
- 실패 시나리오: 일부 작업이 실패하여 트랜잭션이 롤백되는 경우

### 6.2 Result 객체 변환 테스트

애플리케이션 레이어에서는 도메인 객체를 Result 객체로 변환하는 로직을 테스트합니다.

### 6.3 분기 처리 테스트

조건에 따른 다양한 비즈니스 로직 분기를 테스트합니다.

## 7. 예시 코드

### 트랜잭션 테스트 예시

```kotlin
@DisplayName("주문 퍼사드 테스트")
class OrderFacadeTest {

    @MockK
    private lateinit var orderService: OrderService
    
    @MockK
    private lateinit var userPointService: UserPointService
    
    @InjectMockKs
    private lateinit var orderFacade: OrderFacade
    
    @BeforeEach
    fun setUp() {
        MockKAnnotations.init(this)
        clearAllMocks()
    }
    
    @Nested
    @DisplayName("포인트 사용 주문 시")
    inner class OrderWithPoints {
        
        @Test
        @DisplayName("정상 처리되면 포인트가 차감되고 주문이 생성되어야 한다")
        fun whenSuccessful_deductsPointsAndCreatesOrder() {
            // given
            val userId = "user1"
            val orderAmount = 10000L
            val usePoints = 1000L
            
            val userPoint = UserPoint(userId, 2000)
            
            every { userPointService.findByUserId(userId) } returns userPoint
            every { userPointService.use(any()) } returns userPoint.copy(point = 1000)
            every { orderService.createOrder(any()) } returns Order("order1", userId, 9000)
            
            // when
            val result = orderFacade.placeOrder(OrderCriteria.Create(
                userId = userId,
                totalAmount = orderAmount,
                usePoints = usePoints
            ))
            
            // then
            assertEquals(9000, result.finalAmount)
            verify { userPointService.use(match { it.amount == 1000L }) }
            verify { orderService.createOrder(any()) }
        }
        
        @Test
        @DisplayName("주문 생성 실패 시 포인트 차감이 롤백되어야 한다")
        fun whenOrderCreationFails_rollbacksPointDeduction() {
            // given
            val userId = "user1"
            val orderAmount = 10000L
            val usePoints = 1000L
            
            every { userPointService.use(any()) } returns mockk()
            every { orderService.createOrder(any()) } throws RuntimeException("주문 생성 실패")
            
            // when & then
            assertThrows<RuntimeException> {
                orderFacade.placeOrder(OrderCriteria.Create(
                    userId = userId,
                    totalAmount = orderAmount,
                    usePoints = usePoints
                ))
            }
        }
    }
    
    @Nested
    @DisplayName("쿠폰 적용 시")
    inner class CouponApplication {
        
        @Test
        @DisplayName("유효한 쿠폰으로 할인이 적용되어야 한다")
        fun withValidCoupon_appliesDiscount() {
            // given
            val orderId = "order1"
            val couponId = "coupon1"
            val order = Order(orderId, "user1", 10000)
            val coupon = Coupon(couponId, "10% 할인", DiscountType.PERCENTAGE, "10")
            
            every { orderService.findById(orderId) } returns order
            every { couponService.findById(couponId) } returns coupon
            every { orderService.applyDiscount(any(), any()) } returns 
                order.copy(discountAmount = 1000, finalAmount = 9000)
            
            // when
            val result = orderFacade.applyCoupon(OrderCriteria.ApplyCoupon(
                orderId = orderId,
                couponId = couponId
            ))
            
            // then
            assertEquals(1000, result.discountAmount)
            assertEquals(9000, result.finalAmount)
        }
        
        @Test
        @DisplayName("이미 사용된 쿠폰 적용 시 예외가 발생해야 한다")
        fun withAlreadyUsedCoupon_throwsException() {
            // given
            val orderId = "order1"
            val couponId = "coupon1"
            
            every { couponService.findById(couponId) } returns mockk()
            every { couponService.validate(couponId, "user1") } throws 
                CouponAlreadyUsedException("이미 사용된 쿠폰입니다")
            
            // when & then
            assertThrows<CouponAlreadyUsedException> {
                orderFacade.applyCoupon(OrderCriteria.ApplyCoupon(
                    orderId = orderId,
                    couponId = couponId
                ))
            }
        }
    }
} 