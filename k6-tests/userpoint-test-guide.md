# 사용자 포인트 API 동시성 테스트 가이드

이 디렉토리에는 사용자 포인트 API의 동시성 처리 능력을 테스트하기 위한 k6 스크립트가 포함되어 있습니다.

## 시스템 설계 배경

사용자 포인트 시스템은 금융 데이터와 유사한 특성을 가지며, 높은 신뢰성과 데이터 일관성을 요구합니다. 특히 포인트 충전, 사용, 환불 등의 트랜잭션은 동시성 이슈에 취약하며 데이터 무결성이 손상될 경우 사용자 신뢰 하락과 재정적 손실을 초래할 수 있습니다.

이러한 위험을 최소화하기 위해 현재 시스템은 **이중 락 메커니즘(비관적 락 + 분산 락)**을 채택하고 있습니다. 데이터베이스 수준의 비관적 락(Pessimistic Lock)과 Redis 기반의 분산 락(Distributed Lock)을 동시에 적용함으로써 단일 서버 환경과 다중 서버 환경 모두에서 최대한의 데이터 일관성을 보장하고자 했습니다. 이러한 이중 락 전략이 시스템 성능에 미치는 영향과 실제 동시성 처리 효과를 측정하기 위해 다양한 락 전략에 대한 비교 테스트를 수행하였습니다.

## 테스트 스크립트 설명

1. **userpoint-concurrency-test.js**
   - 동일한 사용자 ID에 대한 포인트 충전 동시성 테스트
   - 비관적 락(Pessimistic Lock) 구현 기반 성능 측정용
   - 동시성 이슈 발견 시 오류 카운트

2. **userpoint-distributed-lock-test.js**
   - 분산 락 적용 후 포인트 충전 동시성 테스트
   - 다양한 부하 시나리오 (일반 분산 테스트, 단일 사용자 집중 테스트)
   - 응답 시간 및 일관성 검증 기능 포함

## 실행 방법

### Docker Compose를 사용한 실행

프로젝트에서는 Docker Compose를 사용하여 애플리케이션과 테스트 환경을 쉽게 설정하고 실행할 수 있습니다.

#### 사전 준비

1. Docker 및 Docker Compose 설치
2. 프로젝트 루트 디렉토리로 이동

#### 테스트 환경 실행

다음 명령어로 전체 테스트 환경(MySQL, 애플리케이션, InfluxDB, Grafana, k6)을 시작합니다:

```bash
# MySQL 서버 시작
docker-compose \
    -f docker-compose.yml \
    -f docker-compose.app.yml \
    up -d 

# 테스트 대상 서버가 완전히 시작될 때까지 대기
sleep 10
```

#### 부하 테스트 실행

다음 명령어로 k6 테스트를 실행합니다:

```bash
# 테스트 1: 비관적 락만 적용 테스트
$env:K6_SCRIPT="userpoint-concurrency-test.js";`
  docker-compose -f docker-compose.yml `
  -f docker-compose.app.yml `
  -f docker-compose.loadtest.yml `
  -f docker-compose.monitoring.yml `
  up k6 --no-deps

# Linux에서는:
# K6_SCRIPT=userpoint-concurrency-test.js \
#   docker-compose -f docker-compose.yml \
#   -f docker-compose.app.yml \
#   -f docker-compose.loadtest.yml \
#   -f docker-compose.monitoring.yml \
#   up k6 --no-deps

# 테스트 2: 비관적 락 + 분산 락 테스트
$env:K6_SCRIPT="userpoint-distributed-lock-test.js";`
  docker-compose -f docker-compose.yml `
  -f docker-compose.app.yml `
  -f docker-compose.loadtest.yml `
  -f docker-compose.monitoring.yml `
  up k6 --no-deps

# Linux에서는:
# K6_SCRIPT=userpoint-distributed-lock-test.js \
#   docker-compose -f docker-compose.yml \
#   -f docker-compose.app.yml \
#   -f docker-compose.loadtest.yml \
#   -f docker-compose.monitoring.yml \
#   up k6 --no-deps

# 단일 사용자 집중 테스트만 실행 (비관적 락 + 분산 락)
$env:K6_SCRIPT="userpoint-distributed-lock-test.js";`
  $env:K6_ONLY_SCENARIO="single_user_spike";`
  docker-compose -f docker-compose.yml `
  -f docker-compose.app.yml `
  -f docker-compose.loadtest.yml `
  -f docker-compose.monitoring.yml `
  up k6 --no-deps

# Linux에서는:
# K6_SCRIPT=userpoint-distributed-lock-test.js \
#   K6_ONLY_SCENARIO=single_user_spike \
#   docker-compose -f docker-compose.yml \
#   -f docker-compose.app.yml \
#   -f docker-compose.loadtest.yml \
#   -f docker-compose.monitoring.yml \
#   up k6 --no-deps
```

#### 테스트 결과 확인

Grafana 대시보드를 통해 테스트 결과를 확인할 수 있습니다:
- URL: http://localhost:3000
- 기본 계정: admin / admin

#### 환경 정리

테스트가 완료된 후 다음 명령어로 환경을 정리합니다:

```bash
# 부하 테스트 환경 중지
docker-compose -f docker-compose.yml -f docker-compose.app.yml -f docker-compose.loadtest.yml -f docker-compose.monitoring.yml down
```

### 로컬 환경에서 직접 실행 (선택사항)

k6를 로컬에 설치한 경우 다음과 같이 직접 실행할 수도 있습니다:

```bash
# 테스트 1: 비관적 락만 적용된 테스트
k6 run --env API_HOST=localhost:8080 k6-tests/userpoint-concurrency-test.js

# 테스트 2: 비관적 락 + 분산 락 적용된 테스트
k6 run --env API_HOST=localhost:8080 k6-tests/userpoint-distributed-lock-test.js
```

## 테스트 메트릭 설명

### userpoint-concurrency-test.js 메트릭 (비관적 락)

- **concurrency_failures**: 동시성 처리 실패 횟수
- **expected_amount_mismatch**: 예상 금액과 실제 금액 불일치 횟수
- **success_rate**: 요청 성공률

### userpoint-distributed-lock-test.js 메트릭 (비관적 락 + 분산 락)

- **point_charge_errors**: 포인트 충전 요청 실패 횟수
- **point_charge_time**: 포인트 충전 요청 응답 시간 (ms)
- **point_charge_success**: 포인트 충전 요청 성공률
- **point_consistency_failures**: 포인트 일관성 검증 실패 횟수

## 테스트 결과 비교

세 가지 테스트 시나리오의 결과를 비교하여 다음을 확인할 수 있습니다:

1. 비관적 락 vs 비관적 락 + 분산 락 vs 분산 락만 적용의 성능 차이
2. 각 방식의 동시성 이슈 해결 능력
3. 응답 시간 변화 및 오버헤드 비교
4. 대규모 부하에서의 안정성 차이

## 테스트 조정

필요에 따라 다음 항목을 조정할 수 있습니다:

- `options.scenarios`: 부하 테스트 시나리오 설정
- `TEST_USER_ID` 또는 `singleTestUserId`: 테스트 대상 사용자 ID
- `CHARGE_AMOUNT` 또는 `chargeAmount`: 충전 금액
- `thresholds`: 성능 임계값 설정 

## 테스트 결과 예시

### 비관적 락만 적용한 테스트 결과

#### 테스트 환경
- 테스트 기간: 약 2분 1.1초
- 최대 VU(가상 사용자): 150명 (분산 테스트 100VU, 단일 사용자 스파이크 50VU)
- 총 반복 실행: 7,600회
- 초당 평균 반복: 62.76/초

#### 주요 임계값 결과
```
  █ THRESHOLDS
    http_req_duration
    ✓ 'p(95)<500' p(95)=7.64ms

    point_charge_errors
    ✓ 'count<50' count=0

    point_charge_success
    ✓ 'rate>0.95' rate=100.00%

    point_consistency_failures
    ✗ 'count<5' count=20
```

#### 성능 지표
- **응답 시간:** 
  - 평균: 64.27ms
  - 중앙값: 4.05ms
  - 최대: 1분 31초
  - p(95): 7.64ms

- **검증 결과:**
  - 총 15,197개 검증 중 99.98% 성공 (3개 실패)
  - 충전 요청 성공: 99.96% (7,597 성공 / 3 실패)
  - 포인트 일관성 검증 실패: 20건

#### 분석

1. **우수한 API 응답 성능**
   - p95 응답 시간이 7.64ms로 매우 양호하며, 중앙값은 4.05ms로 대부분의 요청이 빠르게 처리됨
   - 평균 응답 시간(64.27ms)과 중앙값(4.05ms)의 차이는 일부 요청에서 지연이 발생했음을 의미
   - 최대 응답 시간이 1분 31초로 높게 나타나, 일부 상황에서 긴 지연이 발생할 수 있음을 시사

2. **동시성 이슈 발생**
   - 포인트 일관성 검증 실패가 20건 발생하여 임계값 테스트(count<5)에 실패
   - 비관적 락만으로는 동일 사용자에 대한 동시 요청 처리 시 데이터 일관성을 완벽히 보장하지 못함
   - 특히 단일 사용자에 대한 집중 테스트(single_user_spike)에서 일관성 문제가 더 두드러짐

3. **API 자체 성공률은 높음**
   - 충전 요청 자체는 99.96%의 높은 성공률을 보임
   - HTTP 요청 실패율이 0.01%로 매우 낮음
   - 비관적 락이 API 기능 동작 자체는 안정적으로 보장함을 확인

4. **처리량 분석**
   - 초당 평균 62.76회의 반복 처리를 달성하여 높은 처리량을 보임
   - 비관적 락만 사용했음에도 처리 용량이 충분함을 시사

5. **개선 방향**
   - 동시성 처리 강화를 위한 추가적인 메커니즘(분산 락 등) 도입 필요
   - 일관성 검증 실패가 발생한 20건의 케이스에 대한 상세 분석 필요
   - 최대 응답 시간(1분 31초) 발생 원인 규명 및 최적화 방안 검토 필요

### 비관적 락 + 분산 락 테스트 결과

#### 테스트 환경
- 테스트 기간: 약 2분 1.7초
- 최대 VU(가상 사용자): 150명 (분산 테스트 100VU, 단일 사용자 스파이크 50VU)
- 총 반복 실행: 7,600회
- 초당 평균 반복: 62.43/초

#### 주요 임계값 결과
```
  █ THRESHOLDS                                       
    http_req_duration                                
    ✓ 'p(95)<500' p(95)=10.49ms                      
                                                     
    point_charge_errors
    ✓ 'count<50' count=1                             
                                                     
    point_charge_success                             
    ✓ 'rate>0.95' rate=99.98%
                                                     
    point_consistency_failures                       
    ✓ 'count<5' count=1                              
```

#### 성능 지표
- **응답 시간:** 
  - 평균: 119.48ms
  - 중앙값: 5.16ms
  - 최대: 1분 31초
  - p(95): 10.49ms

- **검증 결과:**
  - 총 15,200개 검증 중 99.98% 성공 (2개 실패)
  - 충전 요청 성공: 99.99% (7,599 성공 / 1 실패)
  - 응답 데이터 포함: 99.99% (7,599 성공 / 1 실패)
  - 포인트 일관성 검증 실패: 1건

#### 분석

1. **높은 안정성**
   - 비관적 락과 분산 락을 동시에 적용한 환경에서도 99.98%의 높은 성공률을 보여줌
   - 7,600회의 반복 실행 중 단 1건의 포인트 충전 오류와 일관성 검증 실패가 발생
   - 임계값(threshold) 테스트를 모두 통과하여 시스템이 안정적으로 동작함을 확인

2. **응답 시간 특성**
   - p95 응답 시간이 10.49ms로 매우 양호하며, 중앙값은 5.16ms로 대부분의 요청이 빠르게 처리됨
   - 평균 응답 시간(119.48ms)과 중앙값(5.16ms)의 큰 차이는 일부 요청에서 지연이 발생했음을 의미
   - 최대 응답 시간이 1분 31초로 높게 나타나, 일부 상황에서 긴 지연이 발생할 수 있음을 시사

3. **동시성 처리 효과**
   - 이중 락 메커니즘(비관적 락 + 분산 락)이 동시성 문제를 효과적으로 방지
   - 150명의 동시 사용자를 처리하면서도 데이터 일관성을 유지
   - 특히 단일 사용자에 대한 집중 테스트(single_user_spike)에서도 안정적으로 작동

4. **오버헤드 평가**
   - 각 반복 실행의 평균 소요 시간은 536.3ms로, 실제 API 응답 시간(119.48ms)보다 높음
   - 이는 분산 락 획득/해제 및 비관적 락 처리에 따른 오버헤드로 볼 수 있음
   - 그러나 이러한 오버헤드에도 불구하고 초당 62.43회의 반복 처리가 가능하여 높은 처리량을 보임

5. **개선 가능성**
   - 총 2건의 오류만 발생했으나, 해당 오류의 원인 분석 및 개선 방안 수립 필요
   - 최대 응답 시간(1분 31초)이 발생한 상황에 대한 추가 분석 필요
   - 이중 락 적용으로 인한 오버헤드가 실제 운영 환경에서 감내할 수 있는 수준인지 평가 필요

### 분산 락만 적용한 테스트 결과

#### 테스트 환경
- 테스트 기간: 약 2분 0.9초
- 최대 VU(가상 사용자): 150명 (분산 테스트 100VU, 단일 사용자 스파이크 50VU)
- 총 반복 실행: 7,600회
- 초당 평균 반복: 62.86/초

#### 주요 임계값 결과
```
  █ THRESHOLDS
    http_req_duration
    ✓ 'p(95)<500' p(95)=6.85ms

    point_charge_errors
    ✓ 'count<50' count=0

    point_charge_success
    ✓ 'rate>0.95' rate=100.00%

    point_consistency_failures
    ✓ 'count<5' count=2
```

#### 성능 지표
- **응답 시간:** 
  - 평균: 81.99ms
  - 중앙값: 4.1ms
  - 최대: 1분 31초
  - p(95): 6.85ms

- **검증 결과:**
  - 총 15,197개 검증 중 99.98% 성공 (3개 실패)
  - 충전 요청 성공: 99.96% (7,597 성공 / 3 실패)
  - 포인트 일관성 검증 실패: 2건

#### 분석

1. **균형 잡힌 성능과 일관성**
   - 분산 락만 적용했음에도 p95 응답 시간이 6.85ms로 매우 양호
   - 비관적 락만 사용했을 때보다 더 빠른 p95 응답 시간을 보임
   - 포인트 일관성 검증에서 비관적 락(20건 실패)보다 훨씬 우수한 결과(2건 실패)를 보여줌

2. **일관성 확보**
   - 분산 락만으로도 임계값 테스트(count<5)를 통과하여 충분한 데이터 일관성 제공
   - 비관적 락만 사용했을 때 발생한 동시성 이슈를 효과적으로 방지
   - 2건의 일관성 검증 실패는 이중 락 사용(1건 실패)에 비해 약간 높지만, 허용 범위 내

3. **성능 효율성**
   - 평균 응답 시간(81.99ms)은 비관적 락만 사용(64.27ms)보다는 느리지만
   - 이중 락 적용(119.48ms)에 비해 31% 빠른 응답 속도를 보임
   - 중앙값 응답 시간(4.1ms)도 다른 방식과 비슷한 수준을 유지

4. **처리량과 확장성**
   - 초당 평균 62.86회의 반복 처리로, 세 가지 방식 중 가장 높은 처리량을 보임
   - 동시 사용자를 효율적으로 처리하여 시스템 확장성이 좋음을 시사

5. **총평 및 제안**
   - 응답 시간과 데이터 일관성 측면에서 비관적 락만 사용하는 것보다 우수
   - 이중 락 적용보다 성능 오버헤드가 적으면서 비슷한 수준의 데이터 일관성 제공
   - 분산 환경에서는 분산 락만 적용하는 것이 최적의 선택일 가능성이 높음
   - 운영 환경에서는 데이터베이스 부하와 Redis 부하를 함께 고려한 추가 테스트 필요

## 락 전략 비교 분석 및 권장 사항

### 핵심 메트릭 비교

| 지표 | 비관적 락만 | 비관적 락 + 분산 락 | 분산 락만 |
|------|------------|-------------------|----------|
| p95 응답 시간 | 7.64ms | 10.49ms | 6.85ms |
| 평균 응답 시간 | 64.27ms | 119.48ms | 81.99ms |
| 중앙값 응답 시간 | 4.05ms | 5.16ms | 4.1ms |
| 최대 응답 시간 | 1분 31초 | 1분 31초 | 1분 31초 |
| 초당 처리량 | 62.76/초 | 62.43/초 | 62.86/초 |
| 일관성 검증 실패 | 20건 | 1건 | 2건 |
| API 성공률 | 99.96% | 99.99% | 99.96% |

### 전략별 장단점 분석

#### 비관적 락만 사용

**장점:**
- 구현이 단순하고 추가 인프라(Redis 등) 필요 없음
- 평균 응답 시간이 상대적으로 낮음 (64.27ms)
- 단일 서버 환경에서 쉽게 구현 가능

**단점:**
- 동시성 이슈 발생률이 높음 (20건의 일관성 실패)
- 분산 환경에서는 데이터 일관성 보장이 어려움
- 데이터베이스 락에 의존하므로 DB 부하가 증가할 수 있음

#### 비관적 락 + 분산 락 (이중 락)

**장점:**
- 가장 높은 데이터 일관성 보장 (단 1건의 일관성 실패)
- 복잡한 동시성 시나리오에서도 안정적으로 작동
- API 성공률이 가장 높음 (99.99%)

**단점:**
- 응답 시간 오버헤드가 가장 큼 (평균 119.48ms)
- 구현 복잡성 증가 및 두 가지 락 메커니즘 관리 필요
- p95 응답 시간이 세 전략 중 가장 느림 (10.49ms)

#### 분산 락만 사용

**장점:**
- 가장 빠른 p95 응답 시간 (6.85ms)
- 비교적 높은 데이터 일관성 (2건의 일관성 실패)
- 가장 높은 초당 처리량 (62.86/초)

**단점:**
- Redis 등 추가 인프라 구성 및 관리 필요
- 비관적 락보다 약간 높은 평균 응답 시간 (81.99ms)
- Redis 서버 장애 시 대체 전략 필요

### 사용 사례별 권장 전략

1. **단일 서버 환경 & 낮은 동시성**
   - **권장 전략**: 비관적 락만 사용
   - **이유**: 구현이 단순하고 추가 인프라 필요 없이 적절한 성능 확보 가능
   - **주의사항**: 동시성이 증가하면 일관성 문제 발생 가능성 증가

2. **분산 서버 환경 & 중간 수준 동시성**
   - **권장 전략**: 분산 락만 사용
   - **이유**: 분산 환경에서 데이터 일관성 보장하면서도 우수한 성능 제공
   - **주의사항**: Redis 인프라 안정성 확보 필요

3. **금융 거래 등 완벽한 일관성이 필수인 환경**
   - **권장 전략**: 비관적 락 + 분산 락 (이중 락)
   - **이유**: 성능을 일부 희생하더라도 최고 수준의 데이터 일관성 확보
   - **주의사항**: 응답 시간 증가를 감안한 시스템 설계 필요

4. **높은 확장성 요구 & 대규모 트래픽 환경**
   - **권장 전략**: 분산 락만 사용 + 락 세분화
   - **이유**: 확장성이 우수하며 일관성과 성능의 균형이 잘 맞음
   - **주의사항**: 락 키 설계 최적화로 경합 최소화 필요

### 향후 개선 및 테스트 제안

1. **장시간 부하 테스트 수행**
   - 현재 테스트는 약 2분간 진행되었으나, 장시간(1시간 이상) 테스트를 통해 시스템 안정성 검증 필요
   - 메모리 누수, 리소스 고갈 등 장기간 운영 시 발생할 수 있는 문제 파악

2. **락 획득 타임아웃 최적화**
   - 분산 락의 획득 타임아웃 값을 다양하게 설정하여 최적값 도출
   - 타임아웃이 너무 짧으면 불필요한 실패, 너무 길면 대기 시간 증가 발생

3. **장애 시나리오 테스트**
   - Redis 서버 장애, 네트워크 지연 등 다양한 장애 상황에서의 동작 검증
   - 락 획득 실패 시 폴백(fallback) 메커니즘 구현 및 테스트

4. **락 세분화 전략 테스트**
   - 사용자 ID 단위가 아닌 더 세분화된 락 키 설계(예: 사용자ID + 작업유형)
   - 세분화된 락을 통한 경합 감소 및 성능 개선 효과 측정

5. **모니터링 강화**
   - 락 획득/해제 시간, 경합률 등 락 관련 메트릭 모니터링 체계 구축
   - Redis 서버 성능 및 DB 락 상태에 대한 실시간 모니터링 도입

6. **하이브리드 전략 검토**
   - 중요도에 따라 API별로 다른 락 전략 적용
   - 일반 조회는 락 없이, 간단한 변경은 분산 락만, 중요 금융 거래는 이중 락 적용 등

락 전략 선택은 시스템 요구사항, 인프라 환경, 트래픽 패턴에 따라 달라져야 합니다. 이번 테스트 결과를 바탕으로 실제 운영 환경에 맞는 최적의 전략을 선택하고, 지속적인 모니터링과 튜닝을 통해 시스템 안정성과 성능을 개선해 나가는 것이 중요합니다.

### 결론: 현재 적용된 이중 락 전략에 대한 평가

사용자 포인트 시스템에 현재 적용 중인 이중 락 전략(비관적 락 + 분산 락)은 테스트 결과에서 확인된 바와 같이 **가장 높은 데이터 일관성**을 제공합니다. 포인트 충전 및 사용과 같은 금융적 성격의 트랜잭션에서는 데이터 무결성이 무엇보다 중요하기 때문에, 이중 락 전략은 적절한 선택이라고 판단됩니다.

특히 일관성 검증 실패가 비관적 락만 사용했을 때 20건에서 이중 락 적용 시 1건으로 95% 감소한 것은 매우 의미 있는 성과입니다. 사용자 포인트 시스템에서 데이터 불일치로 인한 금전적 손실 가능성과 고객 신뢰도 하락 위험을 고려할 때, 이러한 일관성 향상은 응답 시간 증가라는 트레이드오프를 상쇄할 만한 가치가 있습니다.

다만, 테스트 결과에서 분산 락만 사용하는 경우에도 일관성 검증 실패가 2건으로 허용 가능한 수준을 보여주었고, p95 응답 시간이 가장 빨랐다는 점은 주목할 만합니다. 따라서 향후 시스템 개선 시에는 다음과 같은 접근법을 고려해볼 수 있습니다:

1. **API 중요도에 따른 락 전략 차등 적용**
   - 핵심 금융 트랜잭션(충전, 환불 등): 현재의 이중 락 유지
   - 조회 및 통계성 작업: 락 없이 처리
   - 중요도가 중간인 작업: 분산 락만 적용

2. **성능 최적화 노력 병행**
   - 이중 락으로 인한 응답 시간 오버헤드(평균 119.48ms)를 개선하기 위한 튜닝
   - Redis 서버 최적화 및 커넥션 풀 관리 개선
   - 락 획득/해제 프로세스 효율화

**최종 권장사항**: 현재 운영 중인 포인트 시스템에서는 데이터 일관성의 중요성을 고려하여 이중 락 전략을 유지하되, 향후 시스템 규모 확장 시 일부 API에 대해 분산 락만 적용하는 방식으로 점진적 전환을 고려하는 것이 바람직합니다. 이는 데이터 안정성을 유지하면서도 시스템 성능을 최적화할 수 있는 균형 잡힌 접근법이 될 것입니다. 