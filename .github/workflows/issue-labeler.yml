name: Issue Labeler

on:
  issues:
    types: [opened, edited]

# GitHub Actionsì˜ ê¶Œí•œ ì„¤ì • ì¶”ê°€
permissions:
  issues: write
  contents: read
  pull-requests: write

jobs:
  apply-labels:
    runs-on: ubuntu-latest
    steps:
      - name: Apply Labels
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issue = context.payload.issue;
            const body = issue.body;
            
            // ê³µí†µ í•¨ìˆ˜: ë“œë¡­ë‹¤ìš´ ê°’ ì¶”ì¶œ
            const getDropdownValue = (body, label) => {
              const regex = new RegExp(`### ${label}\\s*\\n\\s*([^\\n]+)`, 'i');
              const match = body.match(regex);
              return match ? match[1].trim() : null;
            };
            
            // ê³µí†µ í•¨ìˆ˜: ì²´í¬ë°•ìŠ¤ ê°’ ì¶”ì¶œ
            const getSelectedCheckboxes = (body, section) => {
              const regex = new RegExp(`### ${section}[\\s\\S]*?\\n((?:- \\[[xX]\\] .*\\n)*)`, 'i');
              const match = body.match(regex);
              if (!match || !match[1]) return [];
              
              const checkboxLines = match[1].split('\n').filter(line => line.trim());
              return checkboxLines
                .filter(line => line.match(/- \[[xX]\]/))
                .map(line => {
                  const labelMatch = line.match(/- \[[xX]\] (.*)/);
                  return labelMatch ? labelMatch[1].trim() : null;
                })
                .filter(Boolean);
            };
            
            // 1. ê¸°ìˆ ì  ê°œì„  ì´ìŠˆ ì²˜ë¦¬
            if (body.includes('ğŸ“ ê°œì„  ìœ í˜•')) {
              // ìš°ì„ ìˆœìœ„ ë¼ë²¨ ì²˜ë¦¬
              const existingLabels = issue.labels.map(label => label.name);
              const priorityLabels = existingLabels.filter(label => label.startsWith('priority:'));
              
              if (priorityLabels.length > 0) {
                for (const label of priorityLabels) {
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    name: label
                  });
                }
              }
              
              // ìš°ì„ ìˆœìœ„ ë“œë¡­ë‹¤ìš´ ê°’ ì°¾ê¸°
              const priorityValue = getDropdownValue(body, 'ğŸ·ï¸ ìš°ì„ ìˆœìœ„');
              
              if (priorityValue) {
                let priorityLabel = '';
                
                if (priorityValue.startsWith('ë†’ìŒ')) {
                  priorityLabel = 'priority:high';
                } else if (priorityValue.startsWith('ì¤‘ê°„')) {
                  priorityLabel = 'priority:medium';
                } else if (priorityValue.startsWith('ë‚®ìŒ')) {
                  priorityLabel = 'priority:low';
                } else if (priorityValue.startsWith('ë°±ë¡œê·¸')) {
                  priorityLabel = 'priority:backlog';
                }
                
                if (priorityLabel) {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    labels: [priorityLabel]
                  });
                  
                  console.log(`Applied priority label: ${priorityLabel}`);
                }
              }
              
              // ê°œì„  ìœ í˜• ë¼ë²¨ ì²˜ë¦¬
              const typeLabels = existingLabels.filter(label => label.startsWith('type:'));
              
              if (typeLabels.length > 0) {
                for (const label of typeLabels) {
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    name: label
                  });
                }
              }
              
              // ê°œì„  ìœ í˜• ì²´í¬ë°•ìŠ¤ ê°€ì ¸ì˜¤ê¸°
              const selectedTypes = getSelectedCheckboxes(body, 'ğŸ“ ê°œì„  ìœ í˜•');
              
              if (selectedTypes.length > 0) {
                const newLabels = [];
                
                // ì„ íƒëœ ê° ìœ í˜•ì— ëŒ€í•œ ë¼ë²¨ ë§¤í•‘
                const typeMap = {
                  'ì½”ë“œ ë¦¬íŒ©í† ë§': 'type:refactoring',
                  'ì•„í‚¤í…ì²˜ ê°œì„ ': 'type:architecture',
                  'ì„±ëŠ¥ ìµœì í™”': 'type:performance',
                  'ê¸°ìˆ  ë¶€ì±„ í•´ì†Œ': 'type:tech-debt',
                  'ë°ì´í„°ë² ì´ìŠ¤ ìµœì í™”': 'type:database',
                  'ë³´ì•ˆ ê°•í™”': 'type:security',
                  'í…ŒìŠ¤íŠ¸ ê°œì„ ': 'type:testing',
                  'ë¡œê¹…/ëª¨ë‹ˆí„°ë§ ê°œì„ ': 'type:logging',
                  'CI/CD íŒŒì´í”„ë¼ì¸ ê°œì„ ': 'type:ci-cd',
                  'ê¸°íƒ€': 'type:other'
                };
                
                // ì„ íƒëœ ìœ í˜•ë“¤ì— ëŒ€í•œ ë¼ë²¨ ì¶”ê°€
                for (const type of selectedTypes) {
                  // ì •í™•í•œ ë§¤ì¹­ì„ ìœ„í•´ typeê³¼ ê°ì²´ í‚¤ ë¹„êµ
                  Object.keys(typeMap).forEach(key => {
                    if (type.includes(key)) {
                      newLabels.push(typeMap[key]);
                    }
                  });
                }
                
                // ìƒˆ ë¼ë²¨ ì ìš©
                if (newLabels.length > 0) {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    labels: newLabels
                  });
                  
                  console.log(`Applied type labels: ${newLabels.join(', ')}`);
                }
              }
            }
            
            // 2. ê¸°ëŠ¥ ìš”ì²­ ì´ìŠˆ ì²˜ë¦¬
            if (body.includes('ğŸ“ ê¸°ëŠ¥ ìš”ì•½') && body.includes('ğŸ” ê¸°ëŠ¥ ìœ í˜•')) {
              // ìš°ì„ ìˆœìœ„ ë¼ë²¨ ì²˜ë¦¬
              const existingLabels = issue.labels.map(label => label.name);
              const priorityLabels = existingLabels.filter(label => label.startsWith('priority:'));
              
              if (priorityLabels.length > 0) {
                for (const label of priorityLabels) {
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    name: label
                  });
                }
              }
              
              // ìš°ì„ ìˆœìœ„ ë“œë¡­ë‹¤ìš´ ê°’ ì°¾ê¸°
              const priorityValue = getDropdownValue(body, 'ğŸ·ï¸ ìš°ì„ ìˆœìœ„');
              
              if (priorityValue) {
                let priorityLabel = '';
                
                if (priorityValue.startsWith('ë†’ìŒ')) {
                  priorityLabel = 'priority:high';
                } else if (priorityValue.startsWith('ì¤‘ê°„')) {
                  priorityLabel = 'priority:medium';
                } else if (priorityValue.startsWith('ë‚®ìŒ')) {
                  priorityLabel = 'priority:low';
                } else if (priorityValue.startsWith('ì•„ì´ë””ì–´')) {
                  priorityLabel = 'priority:idea';
                }
                
                if (priorityLabel) {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    labels: [priorityLabel]
                  });
                  
                  console.log(`Applied priority label: ${priorityLabel}`);
                }
              }
              
              // ê¸°ëŠ¥ ìœ í˜• ë¼ë²¨ ì²˜ë¦¬
              const featureLabels = existingLabels.filter(label => label.startsWith('feature:'));
              
              if (featureLabels.length > 0) {
                for (const label of featureLabels) {
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    name: label
                  });
                }
              }
              
              // ê¸°ëŠ¥ ìœ í˜• ì²´í¬ë°•ìŠ¤ ê°€ì ¸ì˜¤ê¸°
              const selectedTypes = getSelectedCheckboxes(body, 'ğŸ” ê¸°ëŠ¥ ìœ í˜•');
              
              if (selectedTypes.length > 0) {
                const newLabels = [];
                
                // ì„ íƒëœ ê° ìœ í˜•ì— ëŒ€í•œ ë¼ë²¨ ë§¤í•‘
                const featureMap = {
                  'ì‹ ê·œ ì—”ë“œí¬ì¸íŠ¸': 'feature:new-endpoint',
                  'ê¸°ì¡´ ì—”ë“œí¬ì¸íŠ¸ ê°œì„ ': 'feature:endpoint-enhancement',
                  'ë°ì´í„° ëª¨ë¸ ë³€ê²½': 'feature:data-model',
                  'ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ê°œì„ ': 'feature:business-logic',
                  'ì„±ëŠ¥ ê°œì„ ': 'feature:performance',
                  'ë³´ì•ˆ ê°•í™”': 'feature:security',
                  'API ë¬¸ì„œ ê°œì„ ': 'feature:docs',
                  'ê¸°íƒ€': 'feature:other'
                };
                
                // ì„ íƒëœ ìœ í˜•ë“¤ì— ëŒ€í•œ ë¼ë²¨ ì¶”ê°€
                for (const type of selectedTypes) {
                  Object.keys(featureMap).forEach(key => {
                    if (type.includes(key)) {
                      newLabels.push(featureMap[key]);
                    }
                  });
                }
                
                // ìƒˆ ë¼ë²¨ ì ìš©
                if (newLabels.length > 0) {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    labels: newLabels
                  });
                  
                  console.log(`Applied feature type labels: ${newLabels.join(', ')}`);
                }
              }
            }
            
            // 3. ë²„ê·¸ ë¦¬í¬íŠ¸ ì´ìŠˆ ì²˜ë¦¬
            if (body.includes('ğŸ“ ë²„ê·¸ ì„¤ëª…') && body.includes('ğŸ” ë²„ê·¸ ìœ í˜•')) {
              // ì‹¬ê°ë„ ë¼ë²¨ ì²˜ë¦¬
              const existingLabels = issue.labels.map(label => label.name);
              const severityLabels = existingLabels.filter(label => label.startsWith('severity:'));
              
              if (severityLabels.length > 0) {
                for (const label of severityLabels) {
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    name: label
                  });
                }
              }
              
              // ì‹¬ê°ë„ ë“œë¡­ë‹¤ìš´ ê°’ ì°¾ê¸°
              const severityValue = getDropdownValue(body, 'ğŸ·ï¸ ì‹¬ê°ë„');
              
              if (severityValue) {
                let severityLabel = '';
                
                if (severityValue.startsWith('ê¸´ê¸‰')) {
                  severityLabel = 'severity:critical';
                } else if (severityValue.startsWith('ë†’ìŒ')) {
                  severityLabel = 'severity:high';
                } else if (severityValue.startsWith('ì¤‘ê°„')) {
                  severityLabel = 'severity:medium';
                } else if (severityValue.startsWith('ë‚®ìŒ')) {
                  severityLabel = 'severity:low';
                }
                
                if (severityLabel) {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    labels: [severityLabel]
                  });
                  
                  console.log(`Applied severity label: ${severityLabel}`);
                }
              }
              
              // ë²„ê·¸ ìœ í˜• ë¼ë²¨ ì²˜ë¦¬
              const bugLabels = existingLabels.filter(label => label.startsWith('bug-type:'));
              
              if (bugLabels.length > 0) {
                for (const label of bugLabels) {
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    name: label
                  });
                }
              }
              
              // ë²„ê·¸ ìœ í˜• ì²´í¬ë°•ìŠ¤ ê°€ì ¸ì˜¤ê¸°
              const selectedTypes = getSelectedCheckboxes(body, 'ğŸ” ë²„ê·¸ ìœ í˜•');
              
              if (selectedTypes.length > 0) {
                const newLabels = [];
                
                // ì„ íƒëœ ê° ìœ í˜•ì— ëŒ€í•œ ë¼ë²¨ ë§¤í•‘
                const bugTypeMap = {
                  'ê¸°ëŠ¥ ì˜¤ì‘ë™': 'bug-type:functionality',
                  'ì„±ëŠ¥ ì´ìŠˆ': 'bug-type:performance',
                  'ë°ì´í„° ë¬¸ì œ': 'bug-type:data',
                  'ì¸ì¦/ê¶Œí•œ ë¬¸ì œ': 'bug-type:auth',
                  'ìœ íš¨ì„± ê²€ì‚¬ ì˜¤ë¥˜': 'bug-type:validation',
                  'ì„œë²„ ì—ëŸ¬': 'bug-type:server',
                  'ë³´ì•ˆ ì·¨ì•½ì ': 'bug-type:security',
                  'ê¸°íƒ€': 'bug-type:other'
                };
                
                // ì„ íƒëœ ìœ í˜•ë“¤ì— ëŒ€í•œ ë¼ë²¨ ì¶”ê°€
                for (const type of selectedTypes) {
                  Object.keys(bugTypeMap).forEach(key => {
                    if (type.includes(key)) {
                      newLabels.push(bugTypeMap[key]);
                    }
                  });
                }
                
                // ìƒˆ ë¼ë²¨ ì ìš©
                if (newLabels.length > 0) {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    labels: newLabels
                  });
                  
                  console.log(`Applied bug type labels: ${newLabels.join(', ')}`);
                }
              }
              
              // í™˜ê²½ ì •ë³´ ë¼ë²¨ ì²˜ë¦¬
              // í™˜ê²½ ë¼ë²¨
              const envValue = getDropdownValue(body, 'í™˜ê²½');
              if (envValue) {
                let envLabel = '';
                
                if (envValue.startsWith('ê°œë°œ')) {
                  envLabel = 'env:development';
                } else if (envValue.startsWith('í…ŒìŠ¤íŠ¸')) {
                  envLabel = 'env:testing';
                } else if (envValue.startsWith('ìŠ¤í…Œì´ì§•')) {
                  envLabel = 'env:staging';
                } else if (envValue.startsWith('í”„ë¡œë•ì…˜')) {
                  envLabel = 'env:production';
                }
                
                if (envLabel) {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    labels: [envLabel]
                  });
                  
                  console.log(`Applied environment label: ${envLabel}`);
                }
              }
            } 